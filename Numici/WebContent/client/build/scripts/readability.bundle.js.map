{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "src/readability/Clipper.js",
    "src/readability/Readability.js",
    "src/readability/index.js"
  ],
  "names": [],
  "mappings": "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",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t, n, r) {\r\n\tfunction s(o, u) {\r\n\t\tif (!n[o]) {\r\n\t\t\tif (!t[o]) {\r\n\t\t\t\tvar a = typeof __require__ == \"function\" && __require__;\r\n\t\t\t\tif (!u && a)\r\n\t\t\t\t\treturn a(o, !0);\r\n\t\t\t\tif (i)\r\n\t\t\t\t\treturn i(o, !0);\r\n\t\t\t\tthrow new Error(\"Cannot find module '\" + o + \"'\")\r\n\t\t\t}\r\n\t\t\tvar f = n[o] = {\r\n\t\t\t\texports : {}\r\n\t\t\t};\r\n\t\t\tt[o][0].call(f.exports, function(e) {\r\n\t\t\t\tvar n = t[o][1][e];\r\n\t\t\t\treturn s(n ? n : e)\r\n\t\t\t}, f, f.exports, e, t, n, r)\r\n\t\t}\r\n\t\treturn n[o].exports\r\n\t}\r\n\tvar i = typeof __require__ == \"function\" && __require__;\r\n\tfor (var o = 0; o < r.length; o++)\r\n\t\ts(r[o]);\r\n\treturn s\r\n})",
    "'use strict';\r\nvar Readability = require(\"./Readability\");\r\n\r\nvar READER_DOMAIN_SELECTOR = '.reader-domain';\r\nvar READER_TITLE_SELECTOR = '.reader-title';\r\nvar READER_CREDITS_SELECTOR = '.reader-credits';\r\nvar CONTENT_SELECTOR = '.moz-reader-content';\r\n \t\r\n\t\r\nfunction Clipper() {\r\n\tvar documentClone = document.cloneNode(true); \r\n\tvar article = new Readability(documentClone).parse();\r\n\t/*if(article) {\r\n\t\tif(window.location.href) {\r\n\t\t\tdocument.querySelector(READER_DOMAIN_SELECTOR).href = window.location.href;\r\n\t\t\tdocument.querySelector(READER_DOMAIN_SELECTOR).innerHTML = window.location.href;\r\n\t\t} else {\r\n\t\t\tdocument.querySelector(READER_DOMAIN_SELECTOR).style.display = 'none';\r\n\t\t}\r\n\t\t\r\n\t\tif(article.title) {\r\n\t\t\tdocument.querySelector(READER_TITLE_SELECTOR).innerHTML = article.title;\r\n\t\t} else {\r\n\t\t\tdocument.querySelector(READER_TITLE_SELECTOR).style.display = 'none';\r\n\t\t}\r\n\t\t\r\n\t\tif(article.byline) {\r\n\t\t\tdocument.querySelector(READER_CREDITS_SELECTOR).innerHTML = article.byline;\r\n\t\t} else {\r\n\t\t\tdocument.querySelector(READER_CREDITS_SELECTOR).style.display = 'none';\r\n\t\t}\r\n\t\t\r\n\t\tif(article.content) {\r\n\t\t\tdocument.querySelector(CONTENT_SELECTOR).innerHTML = article.content;\r\n\t\t} else {\r\n\t\t\tdocument.querySelector(CONTENT_SELECTOR).style.display = 'none';\r\n\t\t}\r\n\t\t\r\n\t}*/\r\n\tconsole.log(JSON.stringify(article));\r\n}\r\n\r\n\r\nmodule.exports = Clipper;",
    "/*eslint-env es6:false*/\n/*\n * Copyright (c) 2010 Arc90 Inc\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * This code is heavily based on Arc90's readability.js (1.7.1) script\n * available at: http://code.google.com/p/arc90labs-readability\n */\n\n/**\n * Public constructor.\n * @param {HTMLDocument} doc     The document to parse.\n * @param {Object}       options The options object.\n */\nfunction Readability(doc, options) {\n  // In some older versions, people passed a URI as the first argument. Cope:\n  if (options && options.documentElement) {\n    doc = options;\n    options = arguments[2];\n  } else if (!doc || !doc.documentElement) {\n    throw new Error(\"First argument to Readability constructor should be a document object.\");\n  }\n  options = options || {};\n\n  this._doc = doc;\n  this._articleTitle = null;\n  this._articleByline = null;\n  this._articleDir = null;\n  this._attempts = [];\n\n  // Configurable options\n  this._debug = !!options.debug;\n  this._maxElemsToParse = options.maxElemsToParse || this.DEFAULT_MAX_ELEMS_TO_PARSE;\n  this._nbTopCandidates = options.nbTopCandidates || this.DEFAULT_N_TOP_CANDIDATES;\n  this._charThreshold = options.charThreshold || this.DEFAULT_CHAR_THRESHOLD;\n  this._classesToPreserve = this.CLASSES_TO_PRESERVE.concat(options.classesToPreserve || []);\n\n  // Start with all flags set\n  this._flags = this.FLAG_STRIP_UNLIKELYS |\n                this.FLAG_WEIGHT_CLASSES |\n                this.FLAG_CLEAN_CONDITIONALLY;\n\n  var logEl;\n\n  // Control whether log messages are sent to the console\n  if (this._debug) {\n    logEl = function(e) {\n      var rv = e.nodeName + \" \";\n      if (e.nodeType == e.TEXT_NODE) {\n        return rv + '(\"' + e.textContent + '\")';\n      }\n      var classDesc = e.className && (\".\" + e.className.replace(/ /g, \".\"));\n      var elDesc = \"\";\n      if (e.id)\n        elDesc = \"(#\" + e.id + classDesc + \")\";\n      else if (classDesc)\n        elDesc = \"(\" + classDesc + \")\";\n      return rv + elDesc;\n    };\n    this.log = function () {\n      if (typeof dump !== \"undefined\") {\n        var msg = Array.prototype.map.call(arguments, function(x) {\n          return (x && x.nodeName) ? logEl(x) : x;\n        }).join(\" \");\n        dump(\"Reader: (Readability) \" + msg + \"\\n\");\n      } else if (typeof console !== \"undefined\") {\n        var args = [\"Reader: (Readability) \"].concat(arguments);\n        console.log.apply(console, args);\n      }\n    };\n  } else {\n    this.log = function () {};\n  }\n}\n\nReadability.prototype = {\n  FLAG_STRIP_UNLIKELYS: 0x1,\n  FLAG_WEIGHT_CLASSES: 0x2,\n  FLAG_CLEAN_CONDITIONALLY: 0x4,\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n  ELEMENT_NODE: 1,\n  TEXT_NODE: 3,\n\n  // Max number of nodes supported by this parser. Default: 0 (no limit)\n  DEFAULT_MAX_ELEMS_TO_PARSE: 0,\n\n  // The number of top candidates to consider when analysing how\n  // tight the competition is among candidates.\n  DEFAULT_N_TOP_CANDIDATES: 5,\n\n  // Element tags to score by default.\n  DEFAULT_TAGS_TO_SCORE: \"section,h2,h3,h4,h5,h6,p,td,pre\".toUpperCase().split(\",\"),\n\n  // The default number of chars an article must have in order to return a result\n  DEFAULT_CHAR_THRESHOLD: 500,\n\n  // All of the regular expressions in use within readability.\n  // Defined up here so we don't instantiate them repeatedly in loops.\n  REGEXPS: {\n    unlikelyCandidates: /-ad-|banner|breadcrumbs|combx|comment|community|cover-wrap|disqus|extra|foot|header|legends|menu|related|remark|replies|rss|shoutbox|sidebar|skyscraper|social|sponsor|supplemental|ad-break|agegate|pagination|pager|popup|yom-remote/i,\n    okMaybeItsACandidate: /and|article|body|column|main|shadow/i,\n    positive: /article|body|content|entry|hentry|h-entry|main|page|pagination|post|text|blog|story/i,\n    negative: /hidden|^hid$| hid$| hid |^hid |banner|combx|comment|com-|contact|foot|footer|footnote|masthead|media|meta|outbrain|promo|related|scroll|share|shoutbox|sidebar|skyscraper|sponsor|shopping|tags|tool|widget/i,\n    extraneous: /print|archive|comment|discuss|e[\\-]?mail|share|reply|all|login|sign|single|utility/i,\n    byline: /byline|author|dateline|writtenby|p-author/i,\n    replaceFonts: /<(\\/?)font[^>]*>/gi,\n    normalize: /\\s{2,}/g,\n    videos: /\\/\\/(www\\.)?((dailymotion|youtube|youtube-nocookie|player\\.vimeo|v\\.qq)\\.com|(archive|upload\\.wikimedia)\\.org|player\\.twitch\\.tv)/i,\n    nextLink: /(next|weiter|continue|>([^\\|]|$)|»([^\\|]|$))/i,\n    prevLink: /(prev|earl|old|new|<|«)/i,\n    whitespace: /^\\s*$/,\n    hasContent: /\\S$/,\n  },\n\n  DIV_TO_P_ELEMS: [ \"A\", \"BLOCKQUOTE\", \"DL\", \"DIV\", \"IMG\", \"OL\", \"P\", \"PRE\", \"TABLE\", \"UL\", \"SELECT\" ],\n\n  ALTER_TO_DIV_EXCEPTIONS: [\"DIV\", \"ARTICLE\", \"SECTION\", \"P\"],\n\n  PRESENTATIONAL_ATTRIBUTES: [ \"align\", \"background\", \"bgcolor\", \"border\", \"cellpadding\", \"cellspacing\", \"frame\", \"hspace\", \"rules\", \"style\", \"valign\", \"vspace\" ],\n\n  DEPRECATED_SIZE_ATTRIBUTE_ELEMS: [ \"TABLE\", \"TH\", \"TD\", \"HR\", \"PRE\" ],\n\n  // The commented out elements qualify as phrasing content but tend to be\n  // removed by readability when put into paragraphs, so we ignore them here.\n  PHRASING_ELEMS: [\n    // \"CANVAS\", \"IFRAME\", \"SVG\", \"VIDEO\",\n    \"ABBR\", \"AUDIO\", \"B\", \"BDO\", \"BR\", \"BUTTON\", \"CITE\", \"CODE\", \"DATA\",\n    \"DATALIST\", \"DFN\", \"EM\", \"EMBED\", \"I\", \"IMG\", \"INPUT\", \"KBD\", \"LABEL\",\n    \"MARK\", \"MATH\", \"METER\", \"NOSCRIPT\", \"OBJECT\", \"OUTPUT\", \"PROGRESS\", \"Q\",\n    \"RUBY\", \"SAMP\", \"SCRIPT\", \"SELECT\", \"SMALL\", \"SPAN\", \"STRONG\", \"SUB\",\n    \"SUP\", \"TEXTAREA\", \"TIME\", \"VAR\", \"WBR\"\n  ],\n\n  // These are the classes that readability sets itself.\n  CLASSES_TO_PRESERVE: [ \"page\" ],\n\n  /**\n   * Run any post-process modifications to article content as necessary.\n   *\n   * @param Element\n   * @return void\n  **/\n  _postProcessContent: function(articleContent) {\n    // Readability cannot open relative uris so we convert them to absolute uris.\n    this._fixRelativeUris(articleContent);\n\n    // Remove classes.\n    this._cleanClasses(articleContent);\n  },\n\n  /**\n   * Iterates over a NodeList, calls `filterFn` for each node and removes node\n   * if function returned `true`.\n   *\n   * If function is not passed, removes all the nodes in node list.\n   *\n   * @param NodeList nodeList The nodes to operate on\n   * @param Function filterFn the function to use as a filter\n   * @return void\n   */\n  _removeNodes: function(nodeList, filterFn) {\n    for (var i = nodeList.length - 1; i >= 0; i--) {\n      var node = nodeList[i];\n      var parentNode = node.parentNode;\n      if (parentNode) {\n        if (!filterFn || filterFn.call(this, node, i, nodeList)) {\n          parentNode.removeChild(node);\n        }\n      }\n    }\n  },\n\n  /**\n   * Iterates over a NodeList, and calls _setNodeTag for each node.\n   *\n   * @param NodeList nodeList The nodes to operate on\n   * @param String newTagName the new tag name to use\n   * @return void\n   */\n  _replaceNodeTags: function(nodeList, newTagName) {\n    for (var i = nodeList.length - 1; i >= 0; i--) {\n      var node = nodeList[i];\n      this._setNodeTag(node, newTagName);\n    }\n  },\n\n  /**\n   * Iterate over a NodeList, which doesn't natively fully implement the Array\n   * interface.\n   *\n   * For convenience, the current object context is applied to the provided\n   * iterate function.\n   *\n   * @param  NodeList nodeList The NodeList.\n   * @param  Function fn       The iterate function.\n   * @return void\n   */\n  _forEachNode: function(nodeList, fn) {\n    Array.prototype.forEach.call(nodeList, fn, this);\n  },\n\n  /**\n   * Iterate over a NodeList, return true if any of the provided iterate\n   * function calls returns true, false otherwise.\n   *\n   * For convenience, the current object context is applied to the\n   * provided iterate function.\n   *\n   * @param  NodeList nodeList The NodeList.\n   * @param  Function fn       The iterate function.\n   * @return Boolean\n   */\n  _someNode: function(nodeList, fn) {\n    return Array.prototype.some.call(nodeList, fn, this);\n  },\n\n  /**\n   * Iterate over a NodeList, return true if all of the provided iterate\n   * function calls return true, false otherwise.\n   *\n   * For convenience, the current object context is applied to the\n   * provided iterate function.\n   *\n   * @param  NodeList nodeList The NodeList.\n   * @param  Function fn       The iterate function.\n   * @return Boolean\n   */\n  _everyNode: function(nodeList, fn) {\n    return Array.prototype.every.call(nodeList, fn, this);\n  },\n\n  /**\n   * Concat all nodelists passed as arguments.\n   *\n   * @return ...NodeList\n   * @return Array\n   */\n  _concatNodeLists: function() {\n    var slice = Array.prototype.slice;\n    var args = slice.call(arguments);\n    var nodeLists = args.map(function(list) {\n      return slice.call(list);\n    });\n    return Array.prototype.concat.apply([], nodeLists);\n  },\n\n  _getAllNodesWithTag: function(node, tagNames) {\n    if (node.querySelectorAll) {\n      return node.querySelectorAll(tagNames.join(\",\"));\n    }\n    return [].concat.apply([], tagNames.map(function(tag) {\n      var collection = node.getElementsByTagName(tag);\n      return Array.isArray(collection) ? collection : Array.from(collection);\n    }));\n  },\n\n  /**\n   * Removes the class=\"\" attribute from every element in the given\n   * subtree, except those that match CLASSES_TO_PRESERVE and\n   * the classesToPreserve array from the options object.\n   *\n   * @param Element\n   * @return void\n   */\n  _cleanClasses: function(node) {\n    var classesToPreserve = this._classesToPreserve;\n    var className = (node.getAttribute(\"class\") || \"\")\n      .split(/\\s+/)\n      .filter(function(cls) {\n        return classesToPreserve.indexOf(cls) != -1;\n      })\n      .join(\" \");\n\n    if (className) {\n      node.setAttribute(\"class\", className);\n    } else {\n      node.removeAttribute(\"class\");\n    }\n\n    for (node = node.firstElementChild; node; node = node.nextElementSibling) {\n      this._cleanClasses(node);\n    }\n  },\n\n  /**\n   * Converts each <a> and <img> uri in the given element to an absolute URI,\n   * ignoring #ref URIs.\n   *\n   * @param Element\n   * @return void\n   */\n  _fixRelativeUris: function(articleContent) {\n    var baseURI = this._doc.baseURI;\n    var documentURI = this._doc.documentURI;\n    function toAbsoluteURI(uri) {\n      // Leave hash links alone if the base URI matches the document URI:\n      if (baseURI == documentURI && uri.charAt(0) == \"#\") {\n        return uri;\n      }\n      // Otherwise, resolve against base URI:\n      try {\n        return new URL(uri, baseURI).href;\n      } catch (ex) {\n        // Something went wrong, just return the original:\n      }\n      return uri;\n    }\n\n    var links = articleContent.getElementsByTagName(\"a\");\n    this._forEachNode(links, function(link) {\n      var href = link.getAttribute(\"href\");\n      if (href) {\n        // Replace links with javascript: URIs with text content, since\n        // they won't work after scripts have been removed from the page.\n        if (href.indexOf(\"javascript:\") === 0) {\n          var text = this._doc.createTextNode(link.textContent);\n          link.parentNode.replaceChild(text, link);\n        } else {\n          link.setAttribute(\"href\", toAbsoluteURI(href));\n        }\n      }\n    });\n\n    var imgs = articleContent.getElementsByTagName(\"img\");\n    this._forEachNode(imgs, function(img) {\n      var src = img.getAttribute(\"src\");\n      if (src) {\n        img.setAttribute(\"src\", toAbsoluteURI(src));\n      }\n    });\n  },\n\n  /**\n   * Get the article title as an H1.\n   *\n   * @return void\n   **/\n  _getArticleTitle: function() {\n    var doc = this._doc;\n    var curTitle = \"\";\n    var origTitle = \"\";\n\n    try {\n      curTitle = origTitle = doc.title.trim();\n\n      // If they had an element with id \"title\" in their HTML\n      if (typeof curTitle !== \"string\")\n        curTitle = origTitle = this._getInnerText(doc.getElementsByTagName(\"title\")[0]);\n    } catch (e) {/* ignore exceptions setting the title. */}\n\n    var titleHadHierarchicalSeparators = false;\n    function wordCount(str) {\n      return str.split(/\\s+/).length;\n    }\n\n    // If there's a separator in the title, first remove the final part\n    if ((/ [\\|\\-\\\\\\/>»] /).test(curTitle)) {\n      titleHadHierarchicalSeparators = / [\\\\\\/>»] /.test(curTitle);\n      curTitle = origTitle.replace(/(.*)[\\|\\-\\\\\\/>»] .*/gi, \"$1\");\n\n      // If the resulting title is too short (3 words or fewer), remove\n      // the first part instead:\n      if (wordCount(curTitle) < 3)\n        curTitle = origTitle.replace(/[^\\|\\-\\\\\\/>»]*[\\|\\-\\\\\\/>»](.*)/gi, \"$1\");\n    } else if (curTitle.indexOf(\": \") !== -1) {\n      // Check if we have an heading containing this exact string, so we\n      // could assume it's the full title.\n      var headings = this._concatNodeLists(\n        doc.getElementsByTagName(\"h1\"),\n        doc.getElementsByTagName(\"h2\")\n      );\n      var trimmedTitle = curTitle.trim();\n      var match = this._someNode(headings, function(heading) {\n        return heading.textContent.trim() === trimmedTitle;\n      });\n\n      // If we don't, let's extract the title out of the original title string.\n      if (!match) {\n        curTitle = origTitle.substring(origTitle.lastIndexOf(\":\") + 1);\n\n        // If the title is now too short, try the first colon instead:\n        if (wordCount(curTitle) < 3) {\n          curTitle = origTitle.substring(origTitle.indexOf(\":\") + 1);\n          // But if we have too many words before the colon there's something weird\n          // with the titles and the H tags so let's just use the original title instead\n        } else if (wordCount(origTitle.substr(0, origTitle.indexOf(\":\"))) > 5) {\n          curTitle = origTitle;\n        }\n      }\n    } else if (curTitle.length > 150 || curTitle.length < 15) {\n      var hOnes = doc.getElementsByTagName(\"h1\");\n\n      if (hOnes.length === 1)\n        curTitle = this._getInnerText(hOnes[0]);\n    }\n\n    curTitle = curTitle.trim();\n    // If we now have 4 words or fewer as our title, and either no\n    // 'hierarchical' separators (\\, /, > or ») were found in the original\n    // title or we decreased the number of words by more than 1 word, use\n    // the original title.\n    var curTitleWordCount = wordCount(curTitle);\n    if (curTitleWordCount <= 4 &&\n        (!titleHadHierarchicalSeparators ||\n         curTitleWordCount != wordCount(origTitle.replace(/[\\|\\-\\\\\\/>»]+/g, \"\")) - 1)) {\n      curTitle = origTitle;\n    }\n\n    return curTitle;\n  },\n\n  /**\n   * Prepare the HTML document for readability to scrape it.\n   * This includes things like stripping javascript, CSS, and handling terrible markup.\n   *\n   * @return void\n   **/\n  _prepDocument: function() {\n    var doc = this._doc;\n\n    // Remove all style tags in head\n    this._removeNodes(doc.getElementsByTagName(\"style\"));\n\n    if (doc.body) {\n      this._replaceBrs(doc.body);\n    }\n\n    this._replaceNodeTags(doc.getElementsByTagName(\"font\"), \"SPAN\");\n  },\n\n  /**\n   * Finds the next element, starting from the given node, and ignoring\n   * whitespace in between. If the given node is an element, the same node is\n   * returned.\n   */\n  _nextElement: function (node) {\n    var next = node;\n    while (next\n        && (next.nodeType != this.ELEMENT_NODE)\n        && this.REGEXPS.whitespace.test(next.textContent)) {\n      next = next.nextSibling;\n    }\n    return next;\n  },\n\n  /**\n   * Replaces 2 or more successive <br> elements with a single <p>.\n   * Whitespace between <br> elements are ignored. For example:\n   *   <div>foo<br>bar<br> <br><br>abc</div>\n   * will become:\n   *   <div>foo<br>bar<p>abc</p></div>\n   */\n  _replaceBrs: function (elem) {\n    this._forEachNode(this._getAllNodesWithTag(elem, [\"br\"]), function(br) {\n      var next = br.nextSibling;\n\n      // Whether 2 or more <br> elements have been found and replaced with a\n      // <p> block.\n      var replaced = false;\n\n      // If we find a <br> chain, remove the <br>s until we hit another element\n      // or non-whitespace. This leaves behind the first <br> in the chain\n      // (which will be replaced with a <p> later).\n      while ((next = this._nextElement(next)) && (next.tagName == \"BR\")) {\n        replaced = true;\n        var brSibling = next.nextSibling;\n        next.parentNode.removeChild(next);\n        next = brSibling;\n      }\n\n      // If we removed a <br> chain, replace the remaining <br> with a <p>. Add\n      // all sibling nodes as children of the <p> until we hit another <br>\n      // chain.\n      if (replaced) {\n        var p = this._doc.createElement(\"p\");\n        br.parentNode.replaceChild(p, br);\n\n        next = p.nextSibling;\n        while (next) {\n          // If we've hit another <br><br>, we're done adding children to this <p>.\n          if (next.tagName == \"BR\") {\n            var nextElem = this._nextElement(next.nextSibling);\n            if (nextElem && nextElem.tagName == \"BR\")\n              break;\n          }\n\n          if (!this._isPhrasingContent(next))\n            break;\n\n          // Otherwise, make this node a child of the new <p>.\n          var sibling = next.nextSibling;\n          p.appendChild(next);\n          next = sibling;\n        }\n\n        while (p.lastChild && this._isWhitespace(p.lastChild)) {\n          p.removeChild(p.lastChild);\n        }\n\n        if (p.parentNode.tagName === \"P\")\n          this._setNodeTag(p.parentNode, \"DIV\");\n      }\n    });\n  },\n\n  _setNodeTag: function (node, tag) {\n    this.log(\"_setNodeTag\", node, tag);\n    if (node.__JSDOMParser__) {\n      node.localName = tag.toLowerCase();\n      node.tagName = tag.toUpperCase();\n      return node;\n    }\n\n    var replacement = node.ownerDocument.createElement(tag);\n    while (node.firstChild) {\n      replacement.appendChild(node.firstChild);\n    }\n    node.parentNode.replaceChild(replacement, node);\n    if (node.readability)\n      replacement.readability = node.readability;\n\n    for (var i = 0; i < node.attributes.length; i++) {\n      replacement.setAttribute(node.attributes[i].name, node.attributes[i].value);\n    }\n    return replacement;\n  },\n\n  /**\n   * Prepare the article node for display. Clean out any inline styles,\n   * iframes, forms, strip extraneous <p> tags, etc.\n   *\n   * @param Element\n   * @return void\n   **/\n  _prepArticle: function(articleContent) {\n    this._cleanStyles(articleContent);\n\n    // Check for data tables before we continue, to avoid removing items in\n    // those tables, which will often be isolated even though they're\n    // visually linked to other content-ful elements (text, images, etc.).\n    this._markDataTables(articleContent);\n\n    // Clean out junk from the article content\n    this._cleanConditionally(articleContent, \"form\");\n    this._cleanConditionally(articleContent, \"fieldset\");\n    this._clean(articleContent, \"object\");\n    this._clean(articleContent, \"embed\");\n    this._clean(articleContent, \"h1\");\n    this._clean(articleContent, \"footer\");\n    this._clean(articleContent, \"link\");\n    this._clean(articleContent, \"aside\");\n\n    // Clean out elements have \"share\" in their id/class combinations from final top candidates,\n    // which means we don't remove the top candidates even they have \"share\".\n    this._forEachNode(articleContent.children, function(topCandidate) {\n      this._cleanMatchedNodes(topCandidate, /share/);\n    });\n\n    // If there is only one h2 and its text content substantially equals article title,\n    // they are probably using it as a header and not a subheader,\n    // so remove it since we already extract the title separately.\n    var h2 = articleContent.getElementsByTagName(\"h2\");\n    if (h2.length === 1) {\n      var lengthSimilarRate = (h2[0].textContent.length - this._articleTitle.length) / this._articleTitle.length;\n      if (Math.abs(lengthSimilarRate) < 0.5) {\n        var titlesMatch = false;\n        if (lengthSimilarRate > 0) {\n          titlesMatch = h2[0].textContent.includes(this._articleTitle);\n        } else {\n          titlesMatch = this._articleTitle.includes(h2[0].textContent);\n        }\n        if (titlesMatch) {\n          this._clean(articleContent, \"h2\");\n        }\n      }\n    }\n\n    this._clean(articleContent, \"iframe\");\n    this._clean(articleContent, \"input\");\n    this._clean(articleContent, \"textarea\");\n    this._clean(articleContent, \"select\");\n    this._clean(articleContent, \"button\");\n    this._cleanHeaders(articleContent);\n\n    // Do these last as the previous stuff may have removed junk\n    // that will affect these\n    this._cleanConditionally(articleContent, \"table\");\n    this._cleanConditionally(articleContent, \"ul\");\n    this._cleanConditionally(articleContent, \"div\");\n\n    // Remove extra paragraphs\n    this._removeNodes(articleContent.getElementsByTagName(\"p\"), function (paragraph) {\n      var imgCount = paragraph.getElementsByTagName(\"img\").length;\n      var embedCount = paragraph.getElementsByTagName(\"embed\").length;\n      var objectCount = paragraph.getElementsByTagName(\"object\").length;\n      // At this point, nasty iframes have been removed, only remain embedded video ones.\n      var iframeCount = paragraph.getElementsByTagName(\"iframe\").length;\n      var totalCount = imgCount + embedCount + objectCount + iframeCount;\n\n      return totalCount === 0 && !this._getInnerText(paragraph, false);\n    });\n\n    this._forEachNode(this._getAllNodesWithTag(articleContent, [\"br\"]), function(br) {\n      var next = this._nextElement(br.nextSibling);\n      if (next && next.tagName == \"P\")\n        br.parentNode.removeChild(br);\n    });\n\n    // Remove single-cell tables\n    this._forEachNode(this._getAllNodesWithTag(articleContent, [\"table\"]), function(table) {\n      var tbody = this._hasSingleTagInsideElement(table, \"TBODY\") ? table.firstElementChild : table;\n      if (this._hasSingleTagInsideElement(tbody, \"TR\")) {\n        var row = tbody.firstElementChild;\n        if (this._hasSingleTagInsideElement(row, \"TD\")) {\n          var cell = row.firstElementChild;\n          cell = this._setNodeTag(cell, this._everyNode(cell.childNodes, this._isPhrasingContent) ? \"P\" : \"DIV\");\n          table.parentNode.replaceChild(cell, table);\n        }\n      }\n    });\n  },\n\n  /**\n   * Initialize a node with the readability object. Also checks the\n   * className/id for special names to add to its score.\n   *\n   * @param Element\n   * @return void\n  **/\n  _initializeNode: function(node) {\n    node.readability = {\"contentScore\": 0};\n\n    switch (node.tagName) {\n      case \"DIV\":\n        node.readability.contentScore += 5;\n        break;\n\n      case \"PRE\":\n      case \"TD\":\n      case \"BLOCKQUOTE\":\n        node.readability.contentScore += 3;\n        break;\n\n      case \"ADDRESS\":\n      case \"OL\":\n      case \"UL\":\n      case \"DL\":\n      case \"DD\":\n      case \"DT\":\n      case \"LI\":\n      case \"FORM\":\n        node.readability.contentScore -= 3;\n        break;\n\n      case \"H1\":\n      case \"H2\":\n      case \"H3\":\n      case \"H4\":\n      case \"H5\":\n      case \"H6\":\n      case \"TH\":\n        node.readability.contentScore -= 5;\n        break;\n    }\n\n    node.readability.contentScore += this._getClassWeight(node);\n  },\n\n  _removeAndGetNext: function(node) {\n    var nextNode = this._getNextNode(node, true);\n    node.parentNode.removeChild(node);\n    return nextNode;\n  },\n\n  /**\n   * Traverse the DOM from node to node, starting at the node passed in.\n   * Pass true for the second parameter to indicate this node itself\n   * (and its kids) are going away, and we want the next node over.\n   *\n   * Calling this in a loop will traverse the DOM depth-first.\n   */\n  _getNextNode: function(node, ignoreSelfAndKids) {\n    // First check for kids if those aren't being ignored\n    if (!ignoreSelfAndKids && node.firstElementChild) {\n      return node.firstElementChild;\n    }\n    // Then for siblings...\n    if (node.nextElementSibling) {\n      return node.nextElementSibling;\n    }\n    // And finally, move up the parent chain *and* find a sibling\n    // (because this is depth-first traversal, we will have already\n    // seen the parent nodes themselves).\n    do {\n      node = node.parentNode;\n    } while (node && !node.nextElementSibling);\n    return node && node.nextElementSibling;\n  },\n\n  _checkByline: function(node, matchString) {\n    if (this._articleByline) {\n      return false;\n    }\n\n    if (node.getAttribute !== undefined) {\n      var rel = node.getAttribute(\"rel\");\n    }\n\n    if ((rel === \"author\" || this.REGEXPS.byline.test(matchString)) && this._isValidByline(node.textContent)) {\n      this._articleByline = node.textContent.trim();\n      return true;\n    }\n\n    return false;\n  },\n\n  _getNodeAncestors: function(node, maxDepth) {\n    maxDepth = maxDepth || 0;\n    var i = 0, ancestors = [];\n    while (node.parentNode) {\n      ancestors.push(node.parentNode);\n      if (maxDepth && ++i === maxDepth)\n        break;\n      node = node.parentNode;\n    }\n    return ancestors;\n  },\n\n  /***\n   * grabArticle - Using a variety of metrics (content score, classname, element types), find the content that is\n   *         most likely to be the stuff a user wants to read. Then return it wrapped up in a div.\n   *\n   * @param page a document to run upon. Needs to be a full document, complete with body.\n   * @return Element\n  **/\n  _grabArticle: function (page) {\n    this.log(\"**** grabArticle ****\");\n    var doc = this._doc;\n    var isPaging = (page !== null ? true: false);\n    page = page ? page : this._doc.body;\n\n    // We can't grab an article if we don't have a page!\n    if (!page) {\n      this.log(\"No body found in document. Abort.\");\n      return null;\n    }\n\n    var pageCacheHtml = page.innerHTML;\n\n    while (true) {\n      var stripUnlikelyCandidates = this._flagIsActive(this.FLAG_STRIP_UNLIKELYS);\n\n      // First, node prepping. Trash nodes that look cruddy (like ones with the\n      // class name \"comment\", etc), and turn divs into P tags where they have been\n      // used inappropriately (as in, where they contain no other block level elements.)\n      var elementsToScore = [];\n      var node = this._doc.documentElement;\n\n      while (node) {\n        var matchString = node.className + \" \" + node.id;\n\n        if (!this._isProbablyVisible(node)) {\n          this.log(\"Removing hidden node - \" + matchString);\n          node = this._removeAndGetNext(node);\n          continue;\n        }\n\n        // Check to see if this node is a byline, and remove it if it is.\n        if (this._checkByline(node, matchString)) {\n          node = this._removeAndGetNext(node);\n          continue;\n        }\n\n        // Remove unlikely candidates\n        if (stripUnlikelyCandidates) {\n          if (this.REGEXPS.unlikelyCandidates.test(matchString) &&\n              !this.REGEXPS.okMaybeItsACandidate.test(matchString) &&\n              node.tagName !== \"BODY\" &&\n              node.tagName !== \"A\") {\n            this.log(\"Removing unlikely candidate - \" + matchString);\n            node = this._removeAndGetNext(node);\n            continue;\n          }\n        }\n\n        // Remove DIV, SECTION, and HEADER nodes without any content(e.g. text, image, video, or iframe).\n        if ((node.tagName === \"DIV\" || node.tagName === \"SECTION\" || node.tagName === \"HEADER\" ||\n             node.tagName === \"H1\" || node.tagName === \"H2\" || node.tagName === \"H3\" ||\n             node.tagName === \"H4\" || node.tagName === \"H5\" || node.tagName === \"H6\") &&\n            this._isElementWithoutContent(node)) {\n          node = this._removeAndGetNext(node);\n          continue;\n        }\n\n        if (this.DEFAULT_TAGS_TO_SCORE.indexOf(node.tagName) !== -1) {\n          elementsToScore.push(node);\n        }\n\n        // Turn all divs that don't have children block level elements into p's\n        if (node.tagName === \"DIV\") {\n          // Put phrasing content into paragraphs.\n          var p = null;\n          var childNode = node.firstChild;\n          while (childNode) {\n            var nextSibling = childNode.nextSibling;\n            if (this._isPhrasingContent(childNode)) {\n              if (p !== null) {\n                p.appendChild(childNode);\n              } else if (!this._isWhitespace(childNode)) {\n                p = doc.createElement(\"p\");\n                node.replaceChild(p, childNode);\n                p.appendChild(childNode);\n              }\n            } else if (p !== null) {\n              while (p.lastChild && this._isWhitespace(p.lastChild)) {\n                p.removeChild(p.lastChild);\n              }\n              p = null;\n            }\n            childNode = nextSibling;\n          }\n\n          // Sites like http://mobile.slate.com encloses each paragraph with a DIV\n          // element. DIVs with only a P element inside and no text content can be\n          // safely converted into plain P elements to avoid confusing the scoring\n          // algorithm with DIVs with are, in practice, paragraphs.\n          if (this._hasSingleTagInsideElement(node, \"P\") && this._getLinkDensity(node) < 0.25) {\n            var newNode = node.children[0];\n            node.parentNode.replaceChild(newNode, node);\n            node = newNode;\n            elementsToScore.push(node);\n          } else if (!this._hasChildBlockElement(node)) {\n            node = this._setNodeTag(node, \"P\");\n            elementsToScore.push(node);\n          }\n        }\n        node = this._getNextNode(node);\n      }\n\n      /**\n       * Loop through all paragraphs, and assign a score to them based on how content-y they look.\n       * Then add their score to their parent node.\n       *\n       * A score is determined by things like number of commas, class names, etc. Maybe eventually link density.\n      **/\n      var candidates = [];\n      this._forEachNode(elementsToScore, function(elementToScore) {\n        if (!elementToScore.parentNode || typeof(elementToScore.parentNode.tagName) === \"undefined\")\n          return;\n\n        // If this paragraph is less than 25 characters, don't even count it.\n        var innerText = this._getInnerText(elementToScore);\n        if (innerText.length < 25)\n          return;\n\n        // Exclude nodes with no ancestor.\n        var ancestors = this._getNodeAncestors(elementToScore, 3);\n        if (ancestors.length === 0)\n          return;\n\n        var contentScore = 0;\n\n        // Add a point for the paragraph itself as a base.\n        contentScore += 1;\n\n        // Add points for any commas within this paragraph.\n        contentScore += innerText.split(\",\").length;\n\n        // For every 100 characters in this paragraph, add another point. Up to 3 points.\n        contentScore += Math.min(Math.floor(innerText.length / 100), 3);\n\n        // Initialize and score ancestors.\n        this._forEachNode(ancestors, function(ancestor, level) {\n          if (!ancestor.tagName || !ancestor.parentNode || typeof(ancestor.parentNode.tagName) === \"undefined\")\n            return;\n\n          if (typeof(ancestor.readability) === \"undefined\") {\n            this._initializeNode(ancestor);\n            candidates.push(ancestor);\n          }\n\n          // Node score divider:\n          // - parent:             1 (no division)\n          // - grandparent:        2\n          // - great grandparent+: ancestor level * 3\n          if (level === 0)\n            var scoreDivider = 1;\n          else if (level === 1)\n            scoreDivider = 2;\n          else\n            scoreDivider = level * 3;\n          ancestor.readability.contentScore += contentScore / scoreDivider;\n        });\n      });\n\n      // After we've calculated scores, loop through all of the possible\n      // candidate nodes we found and find the one with the highest score.\n      var topCandidates = [];\n      for (var c = 0, cl = candidates.length; c < cl; c += 1) {\n        var candidate = candidates[c];\n\n        // Scale the final candidates score based on link density. Good content\n        // should have a relatively small link density (5% or less) and be mostly\n        // unaffected by this operation.\n        var candidateScore = candidate.readability.contentScore * (1 - this._getLinkDensity(candidate));\n        candidate.readability.contentScore = candidateScore;\n\n        this.log(\"Candidate:\", candidate, \"with score \" + candidateScore);\n\n        for (var t = 0; t < this._nbTopCandidates; t++) {\n          var aTopCandidate = topCandidates[t];\n\n          if (!aTopCandidate || candidateScore > aTopCandidate.readability.contentScore) {\n            topCandidates.splice(t, 0, candidate);\n            if (topCandidates.length > this._nbTopCandidates)\n              topCandidates.pop();\n            break;\n          }\n        }\n      }\n\n      var topCandidate = topCandidates[0] || null;\n      var neededToCreateTopCandidate = false;\n      var parentOfTopCandidate;\n\n      // If we still have no top candidate, just use the body as a last resort.\n      // We also have to copy the body node so it is something we can modify.\n      if (topCandidate === null || topCandidate.tagName === \"BODY\") {\n        // Move all of the page's children into topCandidate\n        topCandidate = doc.createElement(\"DIV\");\n        neededToCreateTopCandidate = true;\n        // Move everything (not just elements, also text nodes etc.) into the container\n        // so we even include text directly in the body:\n        var kids = page.childNodes;\n        while (kids.length) {\n          this.log(\"Moving child out:\", kids[0]);\n          topCandidate.appendChild(kids[0]);\n        }\n\n        page.appendChild(topCandidate);\n\n        this._initializeNode(topCandidate);\n      } else if (topCandidate) {\n        // Find a better top candidate node if it contains (at least three) nodes which belong to `topCandidates` array\n        // and whose scores are quite closed with current `topCandidate` node.\n        var alternativeCandidateAncestors = [];\n        for (var i = 1; i < topCandidates.length; i++) {\n          if (topCandidates[i].readability.contentScore / topCandidate.readability.contentScore >= 0.75) {\n            alternativeCandidateAncestors.push(this._getNodeAncestors(topCandidates[i]));\n          }\n        }\n        var MINIMUM_TOPCANDIDATES = 3;\n        if (alternativeCandidateAncestors.length >= MINIMUM_TOPCANDIDATES) {\n          parentOfTopCandidate = topCandidate.parentNode;\n          while (parentOfTopCandidate.tagName !== \"BODY\") {\n            var listsContainingThisAncestor = 0;\n            for (var ancestorIndex = 0; ancestorIndex < alternativeCandidateAncestors.length && listsContainingThisAncestor < MINIMUM_TOPCANDIDATES; ancestorIndex++) {\n              listsContainingThisAncestor += Number(alternativeCandidateAncestors[ancestorIndex].includes(parentOfTopCandidate));\n            }\n            if (listsContainingThisAncestor >= MINIMUM_TOPCANDIDATES) {\n              topCandidate = parentOfTopCandidate;\n              break;\n            }\n            parentOfTopCandidate = parentOfTopCandidate.parentNode;\n          }\n        }\n        if (!topCandidate.readability) {\n          this._initializeNode(topCandidate);\n        }\n\n        // Because of our bonus system, parents of candidates might have scores\n        // themselves. They get half of the node. There won't be nodes with higher\n        // scores than our topCandidate, but if we see the score going *up* in the first\n        // few steps up the tree, that's a decent sign that there might be more content\n        // lurking in other places that we want to unify in. The sibling stuff\n        // below does some of that - but only if we've looked high enough up the DOM\n        // tree.\n        parentOfTopCandidate = topCandidate.parentNode;\n        var lastScore = topCandidate.readability.contentScore;\n        // The scores shouldn't get too low.\n        var scoreThreshold = lastScore / 3;\n        while (parentOfTopCandidate.tagName !== \"BODY\") {\n          if (!parentOfTopCandidate.readability) {\n            parentOfTopCandidate = parentOfTopCandidate.parentNode;\n            continue;\n          }\n          var parentScore = parentOfTopCandidate.readability.contentScore;\n          if (parentScore < scoreThreshold)\n            break;\n          if (parentScore > lastScore) {\n            // Alright! We found a better parent to use.\n            topCandidate = parentOfTopCandidate;\n            break;\n          }\n          lastScore = parentOfTopCandidate.readability.contentScore;\n          parentOfTopCandidate = parentOfTopCandidate.parentNode;\n        }\n\n        // If the top candidate is the only child, use parent instead. This will help sibling\n        // joining logic when adjacent content is actually located in parent's sibling node.\n        parentOfTopCandidate = topCandidate.parentNode;\n        while (parentOfTopCandidate.tagName != \"BODY\" && parentOfTopCandidate.children.length == 1) {\n          topCandidate = parentOfTopCandidate;\n          parentOfTopCandidate = topCandidate.parentNode;\n        }\n        if (!topCandidate.readability) {\n          this._initializeNode(topCandidate);\n        }\n      }\n\n      // Now that we have the top candidate, look through its siblings for content\n      // that might also be related. Things like preambles, content split by ads\n      // that we removed, etc.\n      var articleContent = doc.createElement(\"DIV\");\n      if (isPaging)\n        articleContent.id = \"readability-content\";\n\n      var siblingScoreThreshold = Math.max(10, topCandidate.readability.contentScore * 0.2);\n      // Keep potential top candidate's parent node to try to get text direction of it later.\n      parentOfTopCandidate = topCandidate.parentNode;\n      var siblings = parentOfTopCandidate.children;\n\n      for (var s = 0, sl = siblings.length; s < sl; s++) {\n        var sibling = siblings[s];\n        var append = false;\n\n        this.log(\"Looking at sibling node:\", sibling, sibling.readability ? (\"with score \" + sibling.readability.contentScore) : \"\");\n        this.log(\"Sibling has score\", sibling.readability ? sibling.readability.contentScore : \"Unknown\");\n\n        if (sibling === topCandidate) {\n          append = true;\n        } else {\n          var contentBonus = 0;\n\n          // Give a bonus if sibling nodes and top candidates have the example same classname\n          if (sibling.className === topCandidate.className && topCandidate.className !== \"\")\n            contentBonus += topCandidate.readability.contentScore * 0.2;\n\n          if (sibling.readability &&\n              ((sibling.readability.contentScore + contentBonus) >= siblingScoreThreshold)) {\n            append = true;\n          } else if (sibling.nodeName === \"P\") {\n            var linkDensity = this._getLinkDensity(sibling);\n            var nodeContent = this._getInnerText(sibling);\n            var nodeLength = nodeContent.length;\n\n            if (nodeLength > 80 && linkDensity < 0.25) {\n              append = true;\n            } else if (nodeLength < 80 && nodeLength > 0 && linkDensity === 0 &&\n                       nodeContent.search(/\\.( |$)/) !== -1) {\n              append = true;\n            }\n          }\n        }\n\n        if (append) {\n          this.log(\"Appending node:\", sibling);\n\n          if (this.ALTER_TO_DIV_EXCEPTIONS.indexOf(sibling.nodeName) === -1) {\n            // We have a node that isn't a common block level element, like a form or td tag.\n            // Turn it into a div so it doesn't get filtered out later by accident.\n            this.log(\"Altering sibling:\", sibling, \"to div.\");\n\n            sibling = this._setNodeTag(sibling, \"DIV\");\n          }\n\n          articleContent.appendChild(sibling);\n          // siblings is a reference to the children array, and\n          // sibling is removed from the array when we call appendChild().\n          // As a result, we must revisit this index since the nodes\n          // have been shifted.\n          s -= 1;\n          sl -= 1;\n        }\n      }\n\n      if (this._debug)\n        this.log(\"Article content pre-prep: \" + articleContent.innerHTML);\n      // So we have all of the content that we need. Now we clean it up for presentation.\n      this._prepArticle(articleContent);\n      if (this._debug)\n        this.log(\"Article content post-prep: \" + articleContent.innerHTML);\n\n      if (neededToCreateTopCandidate) {\n        // We already created a fake div thing, and there wouldn't have been any siblings left\n        // for the previous loop, so there's no point trying to create a new div, and then\n        // move all the children over. Just assign IDs and class names here. No need to append\n        // because that already happened anyway.\n        topCandidate.id = \"readability-page-1\";\n        topCandidate.className = \"page\";\n      } else {\n        var div = doc.createElement(\"DIV\");\n        div.id = \"readability-page-1\";\n        div.className = \"page\";\n        var children = articleContent.childNodes;\n        while (children.length) {\n          div.appendChild(children[0]);\n        }\n        articleContent.appendChild(div);\n      }\n\n      if (this._debug)\n        this.log(\"Article content after paging: \" + articleContent.innerHTML);\n\n      var parseSuccessful = true;\n\n      // Now that we've gone through the full algorithm, check to see if\n      // we got any meaningful content. If we didn't, we may need to re-run\n      // grabArticle with different flags set. This gives us a higher likelihood of\n      // finding the content, and the sieve approach gives us a higher likelihood of\n      // finding the -right- content.\n      var textLength = this._getInnerText(articleContent, true).length;\n      if (textLength < this._charThreshold) {\n        parseSuccessful = false;\n        page.innerHTML = pageCacheHtml;\n\n        if (this._flagIsActive(this.FLAG_STRIP_UNLIKELYS)) {\n          this._removeFlag(this.FLAG_STRIP_UNLIKELYS);\n          this._attempts.push({articleContent: articleContent, textLength: textLength});\n        } else if (this._flagIsActive(this.FLAG_WEIGHT_CLASSES)) {\n          this._removeFlag(this.FLAG_WEIGHT_CLASSES);\n          this._attempts.push({articleContent: articleContent, textLength: textLength});\n        } else if (this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY)) {\n          this._removeFlag(this.FLAG_CLEAN_CONDITIONALLY);\n          this._attempts.push({articleContent: articleContent, textLength: textLength});\n        } else {\n          this._attempts.push({articleContent: articleContent, textLength: textLength});\n          // No luck after removing flags, just return the longest text we found during the different loops\n          this._attempts.sort(function (a, b) {\n            return a.textLength < b.textLength;\n          });\n\n          // But first check if we actually have something\n          if (!this._attempts[0].textLength) {\n            return null;\n          }\n\n          articleContent = this._attempts[0].articleContent;\n          parseSuccessful = true;\n        }\n      }\n\n      if (parseSuccessful) {\n        // Find out text direction from ancestors of final top candidate.\n        var ancestors = [parentOfTopCandidate, topCandidate].concat(this._getNodeAncestors(parentOfTopCandidate));\n        this._someNode(ancestors, function(ancestor) {\n          if (!ancestor.tagName)\n            return false;\n          var articleDir = ancestor.getAttribute(\"dir\");\n          if (articleDir) {\n            this._articleDir = articleDir;\n            return true;\n          }\n          return false;\n        });\n        return articleContent;\n      }\n    }\n  },\n\n  /**\n   * Check whether the input string could be a byline.\n   * This verifies that the input is a string, and that the length\n   * is less than 100 chars.\n   *\n   * @param possibleByline {string} - a string to check whether its a byline.\n   * @return Boolean - whether the input string is a byline.\n   */\n  _isValidByline: function(byline) {\n    if (typeof byline == \"string\" || byline instanceof String) {\n      byline = byline.trim();\n      return (byline.length > 0) && (byline.length < 100);\n    }\n    return false;\n  },\n\n  /**\n   * Attempts to get excerpt and byline metadata for the article.\n   *\n   * @return Object with optional \"excerpt\" and \"byline\" properties\n   */\n  _getArticleMetadata: function() {\n    var metadata = {};\n    var values = {};\n    var metaElements = this._doc.getElementsByTagName(\"meta\");\n\n    // property is a space-separated list of values\n    var propertyPattern = /\\s*(dc|dcterm|og|twitter)\\s*:\\s*(author|creator|description|title)\\s*/gi;\n\n    // name is a single value\n    var namePattern = /^\\s*(?:(dc|dcterm|og|twitter|weibo:(article|webpage))\\s*[\\.:]\\s*)?(author|creator|description|title)\\s*$/i;\n\n    // Find description tags.\n    this._forEachNode(metaElements, function(element) {\n      var elementName = element.getAttribute(\"name\");\n      var elementProperty = element.getAttribute(\"property\");\n      var content = element.getAttribute(\"content\");\n      var matches = null;\n      var name = null;\n\n      if (elementProperty) {\n        matches = elementProperty.match(propertyPattern);\n        if (matches) {\n          for (var i = matches.length - 1; i >= 0; i--) {\n            // Convert to lowercase, and remove any whitespace\n            // so we can match below.\n            name = matches[i].toLowerCase().replace(/\\s/g, \"\");\n            // multiple authors\n            values[name] = content.trim();\n          }\n        }\n      }\n      if (!matches && elementName && namePattern.test(elementName)) {\n        name = elementName;\n        if (content) {\n          // Convert to lowercase, remove any whitespace, and convert dots\n          // to colons so we can match below.\n          name = name.toLowerCase().replace(/\\s/g, \"\").replace(/\\./g, \":\");\n          values[name] = content.trim();\n        }\n      }\n    });\n\n    // get title\n    metadata.title = values[\"dc:title\"] ||\n                     values[\"dcterm:title\"] ||\n                     values[\"og:title\"] ||\n                     values[\"weibo:article:title\"] ||\n                     values[\"weibo:webpage:title\"] ||\n                     values[\"title\"] ||\n                     values[\"twitter:title\"];\n\n    if (!metadata.title) {\n      metadata.title = this._getArticleTitle();\n    }\n\n    // get author\n    metadata.byline = values[\"dc:creator\"] ||\n                      values[\"dcterm:creator\"] ||\n                      values[\"author\"];\n\n    // get description\n    metadata.excerpt = values[\"dc:description\"] ||\n                       values[\"dcterm:description\"] ||\n                       values[\"og:description\"] ||\n                       values[\"weibo:article:description\"] ||\n                       values[\"weibo:webpage:description\"] ||\n                       values[\"description\"] ||\n                       values[\"twitter:description\"];\n\n    return metadata;\n  },\n\n  /**\n   * Removes script tags from the document.\n   *\n   * @param Element\n  **/\n  _removeScripts: function(doc) {\n    this._removeNodes(doc.getElementsByTagName(\"script\"), function(scriptNode) {\n      scriptNode.nodeValue = \"\";\n      scriptNode.removeAttribute(\"src\");\n      return true;\n    });\n    this._removeNodes(doc.getElementsByTagName(\"noscript\"));\n  },\n\n  /**\n   * Check if this node has only whitespace and a single element with given tag\n   * Returns false if the DIV node contains non-empty text nodes\n   * or if it contains no element with given tag or more than 1 element.\n   *\n   * @param Element\n   * @param string tag of child element\n  **/\n  _hasSingleTagInsideElement: function(element, tag) {\n    // There should be exactly 1 element child with given tag\n    if (element.children.length != 1 || element.children[0].tagName !== tag) {\n      return false;\n    }\n\n    // And there should be no text nodes with real content\n    return !this._someNode(element.childNodes, function(node) {\n      return node.nodeType === this.TEXT_NODE &&\n             this.REGEXPS.hasContent.test(node.textContent);\n    });\n  },\n\n  _isElementWithoutContent: function(node) {\n    return node.nodeType === this.ELEMENT_NODE &&\n      node.textContent.trim().length == 0 &&\n      (node.children.length == 0 ||\n       node.children.length == node.getElementsByTagName(\"br\").length + node.getElementsByTagName(\"hr\").length);\n  },\n\n  /**\n   * Determine whether element has any children block level elements.\n   *\n   * @param Element\n   */\n  _hasChildBlockElement: function (element) {\n    return this._someNode(element.childNodes, function(node) {\n      return this.DIV_TO_P_ELEMS.indexOf(node.tagName) !== -1 ||\n             this._hasChildBlockElement(node);\n    });\n  },\n\n  /***\n   * Determine if a node qualifies as phrasing content.\n   * https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Phrasing_content\n  **/\n  _isPhrasingContent: function(node) {\n    return node.nodeType === this.TEXT_NODE || this.PHRASING_ELEMS.indexOf(node.tagName) !== -1 ||\n      ((node.tagName === \"A\" || node.tagName === \"DEL\" || node.tagName === \"INS\") &&\n        this._everyNode(node.childNodes, this._isPhrasingContent));\n  },\n\n  _isWhitespace: function(node) {\n    return (node.nodeType === this.TEXT_NODE && node.textContent.trim().length === 0) ||\n           (node.nodeType === this.ELEMENT_NODE && node.tagName === \"BR\");\n  },\n\n  /**\n   * Get the inner text of a node - cross browser compatibly.\n   * This also strips out any excess whitespace to be found.\n   *\n   * @param Element\n   * @param Boolean normalizeSpaces (default: true)\n   * @return string\n  **/\n  _getInnerText: function(e, normalizeSpaces) {\n    normalizeSpaces = (typeof normalizeSpaces === \"undefined\") ? true : normalizeSpaces;\n    var textContent = e.textContent.trim();\n\n    if (normalizeSpaces) {\n      return textContent.replace(this.REGEXPS.normalize, \" \");\n    }\n    return textContent;\n  },\n\n  /**\n   * Get the number of times a string s appears in the node e.\n   *\n   * @param Element\n   * @param string - what to split on. Default is \",\"\n   * @return number (integer)\n  **/\n  _getCharCount: function(e, s) {\n    s = s || \",\";\n    return this._getInnerText(e).split(s).length - 1;\n  },\n\n  /**\n   * Remove the style attribute on every e and under.\n   * TODO: Test if getElementsByTagName(*) is faster.\n   *\n   * @param Element\n   * @return void\n  **/\n  _cleanStyles: function(e) {\n    if (!e || e.tagName.toLowerCase() === \"svg\")\n      return;\n\n    // Remove `style` and deprecated presentational attributes\n    for (var i = 0; i < this.PRESENTATIONAL_ATTRIBUTES.length; i++) {\n      e.removeAttribute(this.PRESENTATIONAL_ATTRIBUTES[i]);\n    }\n\n    if (this.DEPRECATED_SIZE_ATTRIBUTE_ELEMS.indexOf(e.tagName) !== -1) {\n      e.removeAttribute(\"width\");\n      e.removeAttribute(\"height\");\n    }\n\n    var cur = e.firstElementChild;\n    while (cur !== null) {\n      this._cleanStyles(cur);\n      cur = cur.nextElementSibling;\n    }\n  },\n\n  /**\n   * Get the density of links as a percentage of the content\n   * This is the amount of text that is inside a link divided by the total text in the node.\n   *\n   * @param Element\n   * @return number (float)\n  **/\n  _getLinkDensity: function(element) {\n    var textLength = this._getInnerText(element).length;\n    if (textLength === 0)\n      return 0;\n\n    var linkLength = 0;\n\n    // XXX implement _reduceNodeList?\n    this._forEachNode(element.getElementsByTagName(\"a\"), function(linkNode) {\n      linkLength += this._getInnerText(linkNode).length;\n    });\n\n    return linkLength / textLength;\n  },\n\n  /**\n   * Get an elements class/id weight. Uses regular expressions to tell if this\n   * element looks good or bad.\n   *\n   * @param Element\n   * @return number (Integer)\n  **/\n  _getClassWeight: function(e) {\n    if (!this._flagIsActive(this.FLAG_WEIGHT_CLASSES))\n      return 0;\n\n    var weight = 0;\n\n    // Look for a special classname\n    if (typeof(e.className) === \"string\" && e.className !== \"\") {\n      if (this.REGEXPS.negative.test(e.className))\n        weight -= 25;\n\n      if (this.REGEXPS.positive.test(e.className))\n        weight += 25;\n    }\n\n    // Look for a special ID\n    if (typeof(e.id) === \"string\" && e.id !== \"\") {\n      if (this.REGEXPS.negative.test(e.id))\n        weight -= 25;\n\n      if (this.REGEXPS.positive.test(e.id))\n        weight += 25;\n    }\n\n    return weight;\n  },\n\n  /**\n   * Clean a node of all elements of type \"tag\".\n   * (Unless it's a youtube/vimeo video. People love movies.)\n   *\n   * @param Element\n   * @param string tag to clean\n   * @return void\n   **/\n  _clean: function(e, tag) {\n    var isEmbed = [\"object\", \"embed\", \"iframe\"].indexOf(tag) !== -1;\n\n    this._removeNodes(e.getElementsByTagName(tag), function(element) {\n      // Allow youtube and vimeo videos through as people usually want to see those.\n      if (isEmbed) {\n        var attributeValues = [].map.call(element.attributes, function(attr) {\n          return attr.value;\n        }).join(\"|\");\n\n        // First, check the elements attributes to see if any of them contain youtube or vimeo\n        if (this.REGEXPS.videos.test(attributeValues))\n          return false;\n\n        // Then check the elements inside this element for the same.\n        if (this.REGEXPS.videos.test(element.innerHTML))\n          return false;\n      }\n\n      return true;\n    });\n  },\n\n  /**\n   * Check if a given node has one of its ancestor tag name matching the\n   * provided one.\n   * @param  HTMLElement node\n   * @param  String      tagName\n   * @param  Number      maxDepth\n   * @param  Function    filterFn a filter to invoke to determine whether this node 'counts'\n   * @return Boolean\n   */\n  _hasAncestorTag: function(node, tagName, maxDepth, filterFn) {\n    maxDepth = maxDepth || 3;\n    tagName = tagName.toUpperCase();\n    var depth = 0;\n    while (node.parentNode) {\n      if (maxDepth > 0 && depth > maxDepth)\n        return false;\n      if (node.parentNode.tagName === tagName && (!filterFn || filterFn(node.parentNode)))\n        return true;\n      node = node.parentNode;\n      depth++;\n    }\n    return false;\n  },\n\n  /**\n   * Return an object indicating how many rows and columns this table has.\n   */\n  _getRowAndColumnCount: function(table) {\n    var rows = 0;\n    var columns = 0;\n    var trs = table.getElementsByTagName(\"tr\");\n    for (var i = 0; i < trs.length; i++) {\n      var rowspan = trs[i].getAttribute(\"rowspan\") || 0;\n      if (rowspan) {\n        rowspan = parseInt(rowspan, 10);\n      }\n      rows += (rowspan || 1);\n\n      // Now look for column-related info\n      var columnsInThisRow = 0;\n      var cells = trs[i].getElementsByTagName(\"td\");\n      for (var j = 0; j < cells.length; j++) {\n        var colspan = cells[j].getAttribute(\"colspan\") || 0;\n        if (colspan) {\n          colspan = parseInt(colspan, 10);\n        }\n        columnsInThisRow += (colspan || 1);\n      }\n      columns = Math.max(columns, columnsInThisRow);\n    }\n    return {rows: rows, columns: columns};\n  },\n\n  /**\n   * Look for 'data' (as opposed to 'layout') tables, for which we use\n   * similar checks as\n   * https://dxr.mozilla.org/mozilla-central/rev/71224049c0b52ab190564d3ea0eab089a159a4cf/accessible/html/HTMLTableAccessible.cpp#920\n   */\n  _markDataTables: function(root) {\n    var tables = root.getElementsByTagName(\"table\");\n    for (var i = 0; i < tables.length; i++) {\n      var table = tables[i];\n      var role = table.getAttribute(\"role\");\n      if (role == \"presentation\") {\n        table._readabilityDataTable = false;\n        continue;\n      }\n      var datatable = table.getAttribute(\"datatable\");\n      if (datatable == \"0\") {\n        table._readabilityDataTable = false;\n        continue;\n      }\n      var summary = table.getAttribute(\"summary\");\n      if (summary) {\n        table._readabilityDataTable = true;\n        continue;\n      }\n\n      var caption = table.getElementsByTagName(\"caption\")[0];\n      if (caption && caption.childNodes.length > 0) {\n        table._readabilityDataTable = true;\n        continue;\n      }\n\n      // If the table has a descendant with any of these tags, consider a data table:\n      var dataTableDescendants = [\"col\", \"colgroup\", \"tfoot\", \"thead\", \"th\"];\n      var descendantExists = function(tag) {\n        return !!table.getElementsByTagName(tag)[0];\n      };\n      if (dataTableDescendants.some(descendantExists)) {\n        this.log(\"Data table because found data-y descendant\");\n        table._readabilityDataTable = true;\n        continue;\n      }\n\n      // Nested tables indicate a layout table:\n      if (table.getElementsByTagName(\"table\")[0]) {\n        table._readabilityDataTable = false;\n        continue;\n      }\n\n      var sizeInfo = this._getRowAndColumnCount(table);\n      if (sizeInfo.rows >= 10 || sizeInfo.columns > 4) {\n        table._readabilityDataTable = true;\n        continue;\n      }\n      // Now just go by size entirely:\n      table._readabilityDataTable = sizeInfo.rows * sizeInfo.columns > 10;\n    }\n  },\n\n  /**\n   * Clean an element of all tags of type \"tag\" if they look fishy.\n   * \"Fishy\" is an algorithm based on content length, classnames, link density, number of images & embeds, etc.\n   *\n   * @return void\n   **/\n  _cleanConditionally: function(e, tag) {\n    if (!this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY))\n      return;\n\n    var isList = tag === \"ul\" || tag === \"ol\";\n\n    // Gather counts for other typical elements embedded within.\n    // Traverse backwards so we can remove nodes at the same time\n    // without effecting the traversal.\n    //\n    // TODO: Consider taking into account original contentScore here.\n    this._removeNodes(e.getElementsByTagName(tag), function(node) {\n      // First check if we're in a data table, in which case don't remove us.\n      var isDataTable = function(t) {\n        return t._readabilityDataTable;\n      };\n\n      if (this._hasAncestorTag(node, \"table\", -1, isDataTable)) {\n        return false;\n      }\n\n      var weight = this._getClassWeight(node);\n      var contentScore = 0;\n\n      this.log(\"Cleaning Conditionally\", node);\n\n      if (weight + contentScore < 0) {\n        return true;\n      }\n\n      if (this._getCharCount(node, \",\") < 10) {\n        // If there are not very many commas, and the number of\n        // non-paragraph elements is more than paragraphs or other\n        // ominous signs, remove the element.\n        var p = node.getElementsByTagName(\"p\").length;\n        var img = node.getElementsByTagName(\"img\").length;\n        var li = node.getElementsByTagName(\"li\").length - 100;\n        var input = node.getElementsByTagName(\"input\").length;\n\n        var embedCount = 0;\n        var embeds = node.getElementsByTagName(\"embed\");\n        for (var ei = 0, il = embeds.length; ei < il; ei += 1) {\n          if (!this.REGEXPS.videos.test(embeds[ei].src))\n            embedCount += 1;\n        }\n\n        var linkDensity = this._getLinkDensity(node);\n        var contentLength = this._getInnerText(node).length;\n\n        var haveToRemove =\n          (img > 1 && p / img < 0.5 && !this._hasAncestorTag(node, \"figure\")) ||\n          (!isList && li > p) ||\n          (input > Math.floor(p/3)) ||\n          (!isList && contentLength < 25 && (img === 0 || img > 2) && !this._hasAncestorTag(node, \"figure\")) ||\n          (!isList && weight < 25 && linkDensity > 0.2) ||\n          (weight >= 25 && linkDensity > 0.5) ||\n          ((embedCount === 1 && contentLength < 75) || embedCount > 1);\n        return haveToRemove;\n      }\n      return false;\n    });\n  },\n\n  /**\n   * Clean out elements whose id/class combinations match specific string.\n   *\n   * @param Element\n   * @param RegExp match id/class combination.\n   * @return void\n   **/\n  _cleanMatchedNodes: function(e, regex) {\n    var endOfSearchMarkerNode = this._getNextNode(e, true);\n    var next = this._getNextNode(e);\n    while (next && next != endOfSearchMarkerNode) {\n      if (regex.test(next.className + \" \" + next.id)) {\n        next = this._removeAndGetNext(next);\n      } else {\n        next = this._getNextNode(next);\n      }\n    }\n  },\n\n  /**\n   * Clean out spurious headers from an Element. Checks things like classnames and link density.\n   *\n   * @param Element\n   * @return void\n  **/\n  _cleanHeaders: function(e) {\n    for (var headerIndex = 1; headerIndex < 3; headerIndex += 1) {\n      this._removeNodes(e.getElementsByTagName(\"h\" + headerIndex), function (header) {\n        return this._getClassWeight(header) < 0;\n      });\n    }\n  },\n\n  _flagIsActive: function(flag) {\n    return (this._flags & flag) > 0;\n  },\n\n  _removeFlag: function(flag) {\n    this._flags = this._flags & ~flag;\n  },\n\n  _isProbablyVisible: function(node) {\n    return node.style.display != \"none\" && !node.hasAttribute(\"hidden\");\n  },\n\n  /**\n   * Decides whether or not the document is reader-able without parsing the whole thing.\n   *\n   * @return boolean Whether or not we suspect parse() will suceeed at returning an article object.\n   */\n  isProbablyReaderable: function(helperIsVisible) {\n    var nodes = this._getAllNodesWithTag(this._doc, [\"p\", \"pre\"]);\n\n    // Get <div> nodes which have <br> node(s) and append them into the `nodes` variable.\n    // Some articles' DOM structures might look like\n    // <div>\n    //   Sentences<br>\n    //   <br>\n    //   Sentences<br>\n    // </div>\n    var brNodes = this._getAllNodesWithTag(this._doc, [\"div > br\"]);\n    if (brNodes.length) {\n      var set = new Set();\n      [].forEach.call(brNodes, function(node) {\n        set.add(node.parentNode);\n      });\n      nodes = [].concat.apply(Array.from(set), nodes);\n    }\n\n    if (!helperIsVisible) {\n      helperIsVisible = this._isProbablyVisible;\n    }\n\n    var score = 0;\n    // This is a little cheeky, we use the accumulator 'score' to decide what to return from\n    // this callback:\n    return this._someNode(nodes, function(node) {\n      if (helperIsVisible && !helperIsVisible(node))\n        return false;\n      var matchString = node.className + \" \" + node.id;\n\n      if (this.REGEXPS.unlikelyCandidates.test(matchString) &&\n          !this.REGEXPS.okMaybeItsACandidate.test(matchString)) {\n        return false;\n      }\n\n      if (node.matches && node.matches(\"li p\")) {\n        return false;\n      }\n\n      var textContentLength = node.textContent.trim().length;\n      if (textContentLength < 140) {\n        return false;\n      }\n\n      score += Math.sqrt(textContentLength - 140);\n\n      if (score > 20) {\n        return true;\n      }\n      return false;\n    });\n  },\n\n  /**\n   * Runs readability.\n   *\n   * Workflow:\n   *  1. Prep the document by removing script tags, css, etc.\n   *  2. Build readability's DOM tree.\n   *  3. Grab the article content from the current dom tree.\n   *  4. Replace the current DOM tree with the new one.\n   *  5. Read peacefully.\n   *\n   * @return void\n   **/\n  parse: function () {\n    // Avoid parsing too large documents, as per configuration option\n    if (this._maxElemsToParse > 0) {\n      var numTags = this._doc.getElementsByTagName(\"*\").length;\n      if (numTags > this._maxElemsToParse) {\n        throw new Error(\"Aborting parsing document; \" + numTags + \" elements found\");\n      }\n    }\n\n    // Remove script tags from the document.\n    this._removeScripts(this._doc);\n\n    this._prepDocument();\n\n    var metadata = this._getArticleMetadata();\n    this._articleTitle = metadata.title;\n\n    var articleContent = this._grabArticle();\n    if (!articleContent)\n      return null;\n\n    this.log(\"Grabbed: \" + articleContent.innerHTML);\n\n    this._postProcessContent(articleContent);\n\n    // If we haven't found an excerpt in the article's metadata, use the article's\n    // first paragraph as the excerpt. This is used for displaying a preview of\n    // the article's content.\n    if (!metadata.excerpt) {\n      var paragraphs = articleContent.getElementsByTagName(\"p\");\n      if (paragraphs.length > 0) {\n        metadata.excerpt = paragraphs[0].textContent.trim();\n      }\n    }\n\n    var textContent = articleContent.textContent;\n    return {\n      title: this._articleTitle,\n      byline: metadata.byline || this._articleByline,\n      dir: this._articleDir,\n      content: articleContent.innerHTML,\n      textContent: textContent,\n      length: textContent.length,\n      excerpt: metadata.excerpt,\n    };\n  }\n};\n\nif (typeof module === \"object\") {\n  module.exports = Readability;\n}\n",
    "var Clipper = require(\"./Clipper\");\n\n\n\nClipper();\n"
  ]
}