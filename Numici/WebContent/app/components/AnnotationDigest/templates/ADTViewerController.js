;(function() {
	'use strict';
	
	angular.module('vdvcApp').controller('ADTViewerController',ADTViewerController);
	
	
	angular.module('vdvcApp').directive('annotaionDigestTitle', function($templateCache) {
		  return {
		    restrict: "E",
		    scope: {
		    	taskSpace: "=",
		    	getTitleStyles : "&",
		    },
		    controller : ['$scope', '$element','$q','$timeout',
				function ($scope, $element,$q,$timeout) {
		    	var digestTitleSuffix ="Digest (generated by numici)";
		    	$scope.title = "";
		    	
		    	$scope.titleStyles = function() {
		    		return $scope.getTitleStyles();
		    	};
		    	
		    	function init() {
		    		if($scope.taskSpace) {
		    			$scope.title = $scope.taskSpace.name+" - "+digestTitleSuffix;
		    		} else {
		    			$scope.title =  digestTitleSuffix;
		    		}
		    	}
		    	init();
		    	
		    }],
		    templateUrl: function ($element, $attrs) {
	            return 'app/components/AnnotationDigest/save/digest-title-tmpl.html';
	        }
		   
		};
	});
	
	angular.module('vdvcApp').directive('annotaionDigestTemplate', function($templateCache) {
		  return {
		    restrict: "E",
		    scope: {
		    	taskSpace: "=",
		    	digestData: '=digest',
		    	title:'=',
		    	showNumiciHeader:"@",
		    	numiciImage:"@",
		    	numiciLink:"@",
		    	numiciHeaderText:"@",
		    	numiciFooterText:"@",
		    	digestName:"@",
		    	digestUrl:"@",
		    	description:'@',
		    	contentEditable:'@',
		    	templateUrl:"@",
		    	digestFor :"=",
		    	digestMetaInfoOptions :"=",
		    	enableBorder :"=",
		    	groupBy :"=",
		    	includeDocsWithoutAnn :"=",
		    	imagePosition :"=",
                tableOfContents: "=",
 				tableOfContentsHeading: "@",
		    	displayOrder :"=",
		    	displayReplies :"=",
		    	
		    	setDigesMinMaxWidth : "&",
		    	getTitleStyles : "&",
		    	alternateImageStyles : "&",
		    	setRepDigestStyles : "&",
		    	getAnnotatedText : "&",
		    	formatCreatedDate : "&",
		    	formatComment : "&",
		    	
		    	commentIconUrl : "=",
		    	groupByIndex : "="
		    },
		    controller : ['$scope','AnnotationDigestService',
				function ($scope,AnnotationDigestService) {
		    	
		    	$scope.digesMinMaxWidth = function() {
		    		//return $scope.setDigesMinMaxWidth();
		    		return {'max-width': '648px','color': '#333','line-height': '1.5','margin': '0 auto','font-size': '14px'};
		    	};
		    	$scope.titleStyles = function() {
		    		return $scope.getTitleStyles();
		    	};
		    	$scope.altImageStyles = function() {
		    		return $scope.alternateImageStyles();
		    	};
		    	$scope.repDigestStyles= function(digest) {
		    		return $scope.setRepDigestStyles({digest : digest});
		    	};

				$scope.hasAnnotatedText = AnnotationDigestService.hasAnnotatedText;
		    	$scope.annotatedText = function(annotation) {
		    		return $scope.getAnnotatedText({annotation: annotation});
		    	};
		    	$scope.createdDate = function(dateValue) {
		    		return $scope.formatCreatedDate({dateValue:dateValue});
		    	};
		    	
		    	$scope.convertComment = function(annotation,comment) {
		    		return $scope.formatComment({"annotation":annotation,"comment" : comment});
		    	};
		    	
		    }],
		    link:function(scope){
		        scope.url = scope.templateUrl || 'app/components/AnnotationDigest/save/annotaion-digest-template.html';
		    },
		    /*templateUrl: function ($element, $attrs) {
	              //return $attrs.templateUrl || 'app/components/AnnotationDigest/save/annotaion-digest-template.html';
		    	return '<div ng-include="url"></div>';
	        }*/
		    template: '<div id="annotaion-digest-template" ng-include="url"></div>',
		};
	});
	
	
	angular.module('vdvcApp').directive('annotaionDigestGroupTemplate', function() {
		  return {
		    restrict: "E",
		    scope: {
		    	taskSpace: "=",
		    	groupDigestData: '=digest',
		    	showNumiciHeader:"@",
		    	numiciImage:"@",
		    	numiciLink:"@",
		    	numiciHeaderText:"@",
		    	numiciFooterText:"@",
		    	digestName:'@',
		    	digestUrl:"@",
		    	description:'@',
		    	contentEditable:'@',
		    	templateUrl:"@",
		    	digestFor :"=",
			    digestMetaInfoOptions :"=",
			    enableBorder :"=",
			    groupBy :"=",
			    includeDocsWithoutAnn :"=",
		    	imagePosition : "=",
 				tableOfContents: "=",
			    tableOfContentsHeading: "@",
		    	displayOrder :"=",
		    	displayReplies :"=",
		    	
		    	setDigesMinMaxWidth : "&",
		    	getTitleStyles : "&",
		    	alternateImageStyles : "&",
		    	setRepDigestStyles : "&",
		    	getAnnotatedText : "&",
		    	formatCreatedDate : "&",
		    	formatComment : "&",
		    	
		    	commentIconUrl : "="
		    },
		    controller : ['$scope','AnnotationDigestService',
				function ($scope,AnnotationDigestService) {
				$scope.getTagAsID = AnnotationDigestService.getTagAsID;

		    	$scope.digesMinMaxWidth = function() {
		    		return $scope.setDigesMinMaxWidth();
		    	};
		    	$scope.titleStyles = function() {
		    		return $scope.getTitleStyles();
		    	};
		    	$scope.altImageStyles = function() {
		    		return $scope.alternateImageStyles();
		    	};
		    	$scope.repDigestStyles= function(digest) {
		    		return $scope.setRepDigestStyles({digest : digest});
		    	};

				$scope.hasAnnotatedText = AnnotationDigestService.hasAnnotatedText;

		    	$scope.annotatedText = function(annotation) {
		    		return $scope.getAnnotatedText({annotation: annotation});
		    	};
		    	$scope.createdDate = function(dateValue) {
		    		return $scope.formatCreatedDate({dateValue:dateValue});
		    	};
		    	
		    	$scope.convertComment = function(annotation,comment) {
		    		return $scope.formatComment({"annotation":annotation,"comment" : comment});
		    	};
		    	
		    	$scope.getTagLable = function(name) {
		    		if(name == "$$untagged") {
		    			return "Untagged Annotations";
		    		}
		    		
		    		return name;
		    	};
		    	
		    	$scope.getTagStyles = function(name) {
		    		if(name == "$$untagged") {
		    			return {'color': '#069','padding': '0px'};
		    		}
		    		
		    		return {'color': '#069','padding': '0px'};
		    	};
		    	
		    	$scope.getTagValueLable = function(name, groupBy) {
		    		return AnnotationDigestService.getTagValueLable(name, groupBy);
		    	};
		    }],
		    link:function(scope){
		        scope.url = scope.templateUrl || 'app/components/AnnotationDigest/save/annotaion-digest-template-new.html';
		        scope.grpUrl = 'app/components/AnnotationDigest/save/digest-group-template.html';
		    },
		    template: '<div id="annotaion-digest-group-template" ng-include="grpUrl"></div>',
		  };
	}).directive('digestTableOfContents',function() {
		  return {
		    restrict: "E",
		    scope: {
		    	digestData: '=',
		    	digestMetaInfoOptions :"=",
				tableOfContents: "=",
				tableOfContentsHeading: "@",
				groupBy:"=",
				includeDocsWithoutAnn:"=",
				tableId:'@',
				templateFor:"@",
		    },
		    controller : ['$scope',"AnnotationDigestService",function ($scope,AnnotationDigestService) {
		    	$scope.title = $scope.tableOfContentsHeading || angular.copy(AnnotationDigestService.getTableOfContentsHeading());
				$scope.getTagAsID = function(name) {
					return AnnotationDigestService.getTagAsID(name);
				};
				$scope.getTagValueLable = function(name, groupBy) {
					return AnnotationDigestService.getTagValueLable(name, groupBy);
				};
				$scope.getTagStyles = function(name) {
					return AnnotationDigestService.getTagStyles(name);
				};
				$scope.getTagLable = function(name) {
					return AnnotationDigestService.getTagLable(name);
				};
				
				$scope.getTblOfContLinkStyles = function() {
					return {
						"text-decoration": "none", 
						"color": "#069",
						"font-size": "18px"};
				};
				
				$scope.getTblOfContListStyles = function() {
					return {
						"display": "table",
						"color": "#069",
						"font-size": "18px"
					};
				};
				
				$scope.getTblOfContIndexStyles = function() {
					return {
						"display": "table-cell",
						"padding-right": "20px",
						"font-size": "0.8em",
						"word-break": "keep-all",
						"text-align": "left"
					};
				};
				
				$scope.getTblOfContLableStyles = function() {
					return {
						"display": "table-cell",
						"word-break": "break-word"
					};
				};
		    }],
		    templateUrl: function ($element, $attrs) {
			    if($attrs.templateFor) {
					if($attrs.templateFor == "tag") {
						return 'app/components/AnnotationDigest/save/tbc-tag-tmpl.html'; 
					} else if($attrs.templateFor == "document") {
						return 'app/components/AnnotationDigest/save/tbc-doc-tmpl.html';
					} else if($attrs.templateFor == "section") {
						return 'app/components/AnnotationDigest/save/tbc-sec-tmpl.html';
					}
				}
				return 'app/components/AnnotationDigest/save/tbc-default-tmpl.html';
	        }
		  };
/*	}).directive('digestLinkToTableOfContents',function() {
		  return {
		    restrict: "E",
			replace:true,
		    scope: {
		    	tableId:'@',
		    },
		    template: '<span>&nbsp;<a ng-href="#{{tableId}}" style="text-decoration: none;color: #069;">(top)</a></span>'
		  };*/
	}).directive('digestIframe', ['$state','$compile','$window','$timeout','_', function($state,$compile,$window,$timeout,_) {
		  return {
		    restrict: 'E',
		    scope: {
		      content: '='
		    },
		    link: function(scope, element, attrs) {
			    var docId;
				var annotId;
				var delta = 20;
		        var iframe = document.createElement('iframe');
				iframe.style.outline = "none";
	    		iframe.style.border = "none";
	    		iframe.style.width = "100%";
	    		iframe.style.height = "calc(100% - 10px)";
	    		iframe.style.maxHeight = $(".digest-content-wrap").outerHeight()+"px";
	    		var element0 = element[0];
			    element0.appendChild(iframe);
			
			    scope.$watch('content', function () {
			      iframe.contentWindow.document.open('text/htmlreplace');
			      iframe.contentWindow.document.write(scope.content);
			      iframe.contentWindow.document.close();
			    });

				iframe.onload = (e) => {
					iframe.style.height = iframe.contentWindow.document.documentElement.scrollHeight + 'px';
					iframe.contentWindow.document.documentElement.style.paddingBottom = "10px";
					$timeout(function() {
						if($state.current.name == "tsdigestview") {
							iframe.style.maxHeight = ($(".digest-content-wrap").outerHeight()-10)+"px";
						} else {
							iframe.style.maxHeight = $(".digest-content-wrap").outerHeight()+"px";
						}
					},1000);
					var handleScroll = _.debounce(function() {
						var _document = iframe.contentWindow.document;
						$(_document).find("[data-doc-id]").each(function(i,el) {
							if(isInViewport(el,_document)) {
								docId = $(el).attr("data-doc-id");
								var docInfo = $(el).find("[data-docInfo]");
								//var rect = docEl.getBoundingClientRect();
								if(docInfo && docInfo.length > 0 && !isInViewport(docInfo,_document)) {
									$(el).find("[data-annotId]").each(function(ind,ael) {
										if(isInViewport(ael,_document)) {
											annotId = $(ael).attr("data-annotId");
											return false;
										}
									});
								}
								return false;
							}
						});
					}, 300);
					e.target.contentWindow.addEventListener('scroll', e => {
					  // Enable handleScroll after Implementing showing new digest entries as diffs	
				      // handleScroll();
				      onScroll(e);
				    });
                   if(docId) {
	                    var docEl = $(iframe.contentWindow.document).find("[data-doc-id="+docId+"]");
						if(docEl.length > 0) {
							if(annotId) {
								var annotEl = docEl.find("[data-annotId="+annotId+"]");
								if(annotEl.length > 0) {
									annotEl[0].scrollIntoView();
									return;
								}
							} 
							docEl[0].scrollIntoView();
						}
				   } else {
						iframe.contentWindow.scrollTo(0, 0);
				   }
				}
				angular.element($window).bind('resize', function() {
					$timeout(function() {
						if($state.current.name == "tsdigestview") {
							iframe.style.maxHeight = ($(".digest-content-wrap").outerHeight()-10)+"px";
						} else {
							iframe.style.maxHeight = $(".digest-content-wrap").outerHeight()+"px";
						}
					},1000);
	            });
	            
				function onScroll(evt) {
					if (evt.currentTarget.scrollY > 200) {
						$(angular.element('.vdvc-scroll-top')[0]).css('display','block');
					} else {
						$(angular.element('.vdvc-scroll-top')[0]).css('display','none');
					}
				}

				function isInViewport(el,window) {
					var elementTop = $(el).offset().top+delta;
					var elementBottom = elementTop + $(el).outerHeight()-delta;
					var viewportTop = $(window).scrollTop();
					var viewportBottom = viewportTop + $(window).height();
					return elementBottom > viewportTop && elementTop < viewportBottom;
				};
		    }
		  }
		}
	]).directive('digestIndexer', [function() {
		  return {
		    restrict: 'A',
		    scope: {
		      digestIndexer: '@'
		    },
            controller : ['$scope',function ($scope) {
		    	this.index = $scope.digestIndexer || 0;
                this.incrementIndex = function() {
					this.index++;
					return index;
				}
		    }],
			controllerAs: "di"
		  }
		}
	]);
	
	
	ADTViewerController.$inject = ['$scope','commonService','appData','$state','$stateParams','$uibModal',
	                              '$filter','$compile','$timeout','AnnotationDigestService','TemplateService',
	                              'MessageService','APIUserMessages','defautlDateFormat','DocFactory',
	                              'uuidService','$window','$templateCache','_','$element','TaskSpaceService',
	                              'markdown','Juicify','DeepLinkService','DigestEventListner','notificationEvents'];

	function ADTViewerController($scope,commonService,appData,$state,$stateParams,$uibModal,$filter,$compile,
			$timeout,AnnotationDigestService,TemplateService,MessageService,APIUserMessages,
			defautlDateFormat,DocFactory,uuidService,$window,$templateCache,_,$element,TaskSpaceService,
			markdown,Juicify,DeepLinkService,DigestEventListner,notificationEvents) {
		
		var config = ($scope.taskSpaceState && !_.isEmpty($scope.taskSpaceState.digestsettings) ? 
				angular.copy($scope.taskSpaceState.digestsettings) : 
					angular.copy(AnnotationDigestService.getDigestFilters()));
		
		config.sortOptions = _.isEmpty(config.sortOptions) ? {"timestamp" : "desc"} : config.sortOptions;
		config.groupBy = _.isEmpty(config.groupBy) ? "document" : config.groupBy;
		config.sortBy = _.isEmpty(config.sortBy) ? {"field": "name","order": "asc"} : config.sortBy;
		
		var trustedAnnotatedText = {};
		var fileBaseUrl = commonService.getContext();
		var tsClientId = $scope.tsClientId;
		var adv = this;
		var imageWrapWidthPercent = 35;
		//var digestTemplates;
		
		adv.digestUpdateTitle = angular.copy(AnnotationDigestService.digestUpdateTitle);
		var protectedDocImage = fileBaseUrl+"/app/assets/images/prtectedDocument.png";
		var appdata = appData.getAppData();
		adv.loader = false;
		adv.currentUserId = appdata.UserId;
		adv.createDigestForLink = false;
		adv.openInContextIconUrl = fileBaseUrl+"/app/assets/icons/open_in_context.png";
		adv.commentIconUrl = fileBaseUrl+"/app/assets/icons/digest_comment.png";
		adv.digestFor = "";
		adv.digestData = [];
		adv.digestMetaInfoOptions = angular.copy(config.digestMetaInfoOptions);
		adv.enableBorder = angular.copy(AnnotationDigestService.enableBorder);
		adv.groupBy = angular.copy(AnnotationDigestService.groupBy);
		adv.sortBy = angular.copy(AnnotationDigestService.sortBy);
		adv.includeDocsWithoutAnn = angular.copy(AnnotationDigestService.includeDocsWithoutAnn);
		adv.imagePosition = angular.copy(AnnotationDigestService.imagePosition);
		adv.tableOfContents =  angular.copy(AnnotationDigestService.tableOfContents);
		adv.tableOfContentsHeading = angular.copy(AnnotationDigestService.getTableOfContentsHeading());
		adv.displayOrder = angular.copy(AnnotationDigestService.displayOrder);
		adv.displayReplies = angular.copy(AnnotationDigestService.displayReplies);
		
		adv.digestTitlePrifix = "-Digest (generated by numici)";
		adv.annotationsDigest = annotationsDigest;
		adv.showOpenDigestInNewTabBtn = showOpenDigestInNewTabBtn;
		adv.showCloseDigestBtn = showCloseDigestBtn;
		adv.openDigestInNewTab = openDigestInNewTab;
		adv.closeDigestView = closeDigestView;
		adv.shareDigestLink = shareDigestLink;
		adv.setDigesMinMaxWidth = setDigesMinMaxWidth;
		adv.setRepDigestStyles = setRepDigestStyles;
		adv.getTitleStyles = getTitleStyles;
		adv.setImageWrapStyles = setImageWrapStyles;
		adv.formatCreatedDate = formatCreatedDate;
		adv.alternateImageStyles = alternateImageStyles;
		adv.disablePublish = disablePublish;
		adv.publishToolTipText;
		adv.getAnnotatedText = getAnnotatedText;
		adv.topFunction = topFunction;
		adv.formatComment = formatComment;
		adv.hasDigestUpdates = false;
		adv.numiciImage = appdata.numiciImage;
		adv.numiciLink = appdata.numiciLink;
		adv.numiciHeaderText = appdata.numiciHeaderTxt;
		adv.numiciFooterText = appdata.numiciFooterTxt;
		
		adv.digestContent = "";
		var notificationHandledelayTime = AnnotationDigestService.notificationHandledelayTime;
		var pendingDigestChangedUpdates = [];
		var debounceHandleDigestChangedUpdates = _.debounce(handleDigestChangedUpdates, parseInt(notificationHandledelayTime));
		var loadEvents = [notificationEvents.DIGEST_CHANGED];
		
/*		function getNotificationHandledelayTime() {
			commonService.getNavMenuItems({type: "GlobalSettings",key:"NotificationHandledelayTime"}).then(function(resp) {
				if(resp.data.Status && !_.isEmpty(resp.data.listAppKeyValues)) {
					var notificationHandledelayTimeObj = resp.data.listAppKeyValues[0];
					if(!_.isEmpty(notificationHandledelayTimeObj)) {
						notificationHandledelayTime = notificationHandledelayTimeObj.value;
						debounceHandleDigestChangedUpdates = _.debounce(handleDigestChangedUpdates, notificationHandledelayTime*1000);
					}
				}
			});
		}*/
		
		if(appdata && !_.isEmpty(appdata.GlobalSettings)) {
			var notificationHandledelayTimeObj = _.findWhere(appdata.GlobalSettings,{key : "NotificationHandledelayTime"});
			if(!_.isEmpty(notificationHandledelayTimeObj)) {
				notificationHandledelayTime = notificationHandledelayTimeObj.value*1000;
				debounceHandleDigestChangedUpdates = _.debounce(handleDigestChangedUpdates, parseInt(notificationHandledelayTime));
			}
		}
		
		$scope.$on("resizeDoc",function(event, msg){
			AnnotationDigestService.addBoxShadowToDigest(config.groupBy);
		});
		
		$scope.$on('$destroy',function() {
			DigestEventListner.close();
			debounceHandleDigestChangedUpdates.cancel();
		});
		
		function handleDigestChangedUpdates() {
			if(pendingDigestChangedUpdates && pendingDigestChangedUpdates.length == 0) {
				return;
			}
			pendingDigestChangedUpdates.splice(0,pendingDigestChangedUpdates.length);
			//$window.location.reload();
			//createAnnotationDigest();
			adv.hasDigestUpdates = true;
			$scope.$digest();
		}
		
/*		adv.hasPendingUpdates = function() {
			return pendingDigestChangedUpdates && pendingDigestChangedUpdates.length > 0;
		};*/
		
		adv.updateDigest = function() {
			//handleDigestChangedUpdates();
			adv.hasDigestUpdates = false;
			createAnnotationDigest();
		};
		
		loadEvents.forEach(function (event) {
		   	$scope.$on(event, function (evt, msg) {
/*		   		pendingDigestChangedUpdates.push(msg);
		   		debounceHandleDigestChangedUpdates.cancel();
				if(pendingDigestChangedUpdates.length < AnnotationDigestService.maxNotifications) {
					//debounceHandleDigestChangedUpdates();
				} else {
					//handleDigestChangedUpdates();
				}*/
		   		processDigestEvent(msg);
		    });
		});
		
		function processDigestEvent(msg){
			pendingDigestChangedUpdates.push(msg);
			if(pendingDigestChangedUpdates && pendingDigestChangedUpdates.length == 1) {
				debounceHandleDigestChangedUpdates();
			}
		}
		
		$scope.$on("updateDigest",function(event, msg){
			var handleActionEvents = ["DOCUMENT_INDEXED","DOCS_REMOVED","DOC_OR_SECTION_UPDATE"];
			if(msg && _.contains(handleActionEvents,msg.action)) {
				$scope.taskspace = TaskSpaceService.currentTaskspace;
				//createAnnotationDigest(null,null,null,true);
				//pendingDigestChangedUpdates.push(msg);
				processDigestEvent(msg);
			} else {
				//createAnnotationDigest();
				//pendingDigestChangedUpdates.push({});
				processDigestEvent({});
			}
		});
		
		function getAnnotatedText(annotation) {
			if(!trustedAnnotatedText[annotation.annotationId]) {
				trustedAnnotatedText[annotation.annotationId] = AnnotationDigestService.getAnnotatedText(annotation,adv.digestMetaInfoOptions);
			}
			return trustedAnnotatedText[annotation.annotationId];
		}
		
		function topFunction() {
			(document.getElementsByTagName('iframe')[0]).contentWindow.scrollTo(0,0);
		}
		
		function formatComment(annotation,comment) {
			if(annotation && (annotation.webAnnotation || annotation.documentType == "WebResource")) {
				return $filter('markdown')(comment);
			} else {
				return $filter('linky')(comment,'_blank');
			}

			return comment;
		};
		
		function disablePublish() {
			var status = true;
			if($scope.taskspace && $scope.taskspace.permissions) {
				if(_.isMatch($scope.taskspace.permissions, {owner: true})) {
					status = false;
				} else if(_.isMatch($scope.taskspace.permissions, {edit: true, share: true})) {
					status = false;
				}
			}
			
			adv.publishToolTipText = status ? "You do not have permissions to Share/Save content of this tasksspace" : "Publish";
			return status;
		}
		
		
		function publishToolTip() {
			var status = true;
			if($scope.taskspace && $scope.taskspace.permissions) {
				if(_.isMatch($scope.taskspace.permissions, {edit: true, share: true})) {
					status = false;
				}
			}
			
			return status;
		}
		
		function alternateImageStyles() {
			var imageStyles = {"background-image": "url("+protectedDocImage+")" ,"background-size": "cover"};
			if(!_.isEmpty(adv.enableBorder)) {
				imageStyles["border-width"] = "2px";
				imageStyles["border-color"] = "#000000";
				imageStyles["border-style"] = "solid";
			}
			return imageStyles;
		} 
		
		function formatCreatedDate(dateValue) {
			var date = moment(dateValue,moment.defaultFormat).toDate();
			var formatedDate = $filter('date')(date,'MMM d, y h:mm a');
			return formatedDate;
		}
		
		function setDigesMinMaxWidth() {
			return {'max-width': '648px','color': '#333','line-height': '1.5','margin': '0 auto','font-size': '14px'};
		}
		
		function getTitleStyles() {
			return {'cursor': 'pointer', 'font-weight': '700','margin': '1em 0em','font-size': '16px','margin-block-start':' 1em','margin-block-end': '1em'};
		}
		
		function setImageWrapStyles(digest) {
			return {'width': imageWrapWidthPercent+'%','float': 'left','padding-top': '1em'};
		}
		
		function setRepDigestStyles(digest) {
			if(!_.isEmpty(digest.imageUrl) && adv.digestMetaInfoOptions.image) {
				var width = 100 - imageWrapWidthPercent;
				return {'width': 'calc('+width+'% - 1em)','float': 'left'};
			} else {
				return {'width': '100%'};
			}
		}
				
		function stringifyTags(tags) {
			var tgs = [];
			if(_.isArray(tags)) {
				_.each(tags,function(tag,ind) {
					 var tagString = tag.name;
					 if(_.isArray(tag.values)) {
						 _.each(tag.values,function(val,i) {
							 tagString = tag.name;
							 if(val) {
								 tagString = tagString+":"+val;
							 } 
							 tgs.push(tagString);
						 });
					 } else {
						 tgs.push(tagString);
					 }
				});
			}
			
			return tgs;
		}
		
		function contextLink(digest,annotation,deepLinkId) {
			var link = "";
			if(!annotation && !_.isEmpty(digest.docLink)) {
				link = digest.docLink;
			} else if(annotation && !_.isEmpty(annotation.annotationLink)) {
				link = annotation.annotationLink;
			} else {
				if(!_.isEmpty(deepLinkId)) {
					link = fileBaseUrl+"linkrouter?dlid="+deepLinkId+"&t="+$scope.tsId+"&d="+digest.documentId;
					if(annotation) {
						link = link + "&a="+annotation.annotationId;
					}
				} else {
					link = fileBaseUrl+"list/task/"+$scope.tsId+"?tsc="+$scope.tsClientId+"&d="+digest.documentId+"&dc="+digest.clientId;
					if(digest.sourceURL && digest.documentType == "WebResource") {
						link = fileBaseUrl+"webannotation?target="+encodeURIComponent(digest.sourceURL)+"&cid="+digest.clientId+"&tsId="+$scope.tsId;
						if(annotation) {
							link = link + "&annotationId="+annotation.annotationId;
						}
						return link;
					}
					if(annotation) {
						link = link +"&da="+annotation.annotationId;
					}
				}
			}
			return link;
		}
		
		function preProcessAnnotationDigestResp(saveflag,linkAnnotationDigestResp,deepLinkId) {
            let taskspace = {
				"tsId" : $stateParams.tsId,
				"tsClientId": $stateParams.tsc
			};
			let digestData = AnnotationDigestService.preProcessAnnotationDigestResp(linkAnnotationDigestResp, config,deepLinkId,taskspace);
			if(saveflag) {
				adv.linkDigestData = angular.copy(digestData);
			} else {
				adv.digestData = angular.copy(digestData);
			}
		}
		
		function getDigestContent(saveflag,contenteditable) {
			return $timeout(function() {
				var templateUrl = 'app/components/AnnotationDigest/save/annotaion-digest-template-new.html';
				var roottemplateUrl = 'app/components/AnnotationDigest/save/digest-root.tpl.html';
				
				var tmpl = '';
				var gptmpl = '';
				if(saveflag) {
					tmpl = '<annotaion-digest-template digest="adv.linkDigestData"';
					gptmpl = '<annotaion-digest-group-template digest="adv.linkDigestData"';
				} else {
					tmpl = '<annotaion-digest-template digest="adv.digestData"';
					gptmpl = '<annotaion-digest-group-template digest="adv.digestData"';
				}
				
				tmpl = tmpl+' numici-image="'+adv.numiciImage+'"';
				gptmpl = gptmpl+' numici-image="'+adv.numiciImage+'"';
				
				tmpl = tmpl+' numici-link="'+adv.numiciLink+'"';
				gptmpl = gptmpl+' numici-link="'+adv.numiciLink+'"';
				
				tmpl = tmpl+' numici-header-text="'+adv.numiciHeaderText+'"';
				gptmpl = gptmpl+' numici-header-text="'+adv.numiciHeaderText+'"';
				
				tmpl = tmpl+' numici-footer-text="'+adv.numiciFooterText+'"';
				gptmpl = gptmpl+' numici-footer-text="'+adv.numiciFooterText+'"';
				
				tmpl = tmpl+' show-numici-header="false"';
				gptmpl = gptmpl+' show-numici-header="false"';
				
				if(!_.isEmpty(config.digestName)) {
					tmpl = tmpl+' digest-name="'+config.digestName+'"';
					gptmpl = gptmpl+' digest-name="'+config.digestName+'"';
				} else if($scope.taskspace){
					var digestName = $scope.taskspace.name+ " Digest";
					if(!_.isEmpty(digestName)) {
						tmpl = tmpl+' digest-name="'+digestName+'"';
						gptmpl = gptmpl+' digest-name="'+digestName+'"';
					}
				}
				
				var digestUrl = "";
				if(!_.isEmpty(adv.digestData) && adv.digestFor == "DigestDocument" && adv.digestMetaInfoOptions.documentLink) {
					digestUrl = AnnotationDigestService.getDigestUrlForDocuDigest(adv.groupBy,adv.digestData);
				}
				tmpl = tmpl+' digest-url="'+digestUrl+'"';
				gptmpl = gptmpl+' digest-url="'+digestUrl+'"';
				
				if(!_.isEmpty(config.digestDescription)) {
					var digestDescription = angular.copy(config.digestDescription);
					digestDescription = digestDescription.replace(/(\r\n|\n|\r)/gm, "<br>")
														 .replace(/"/g,"&quot;");
					tmpl = tmpl+' description="'+digestDescription+'"';
					gptmpl = gptmpl+' description="'+digestDescription+'"';
				}
								
/*				tmpl = tmpl+' enable-border="'+adv.enableBorder+'"';
				gptmpl = gptmpl+' enable-border="'+adv.enableBorder+'"';*/
				
				tmpl = tmpl+' template-url="'+templateUrl+'" \
					data-content-editable="'+contenteditable+'"\
					task-space="taskspace"\
					title="true"\
					data-digest-for="adv.digestFor"\
					data-digest-meta-info-options="adv.digestMetaInfoOptions"\
					data-image-position="adv.imagePosition"\
					data-table-of-contents="adv.tableOfContents"\
					data-table-of-contents-heading="{{adv.tableOfContentsHeading}}"\
					data-display-order="adv.displayOrder"\
					data-display-replies="adv.displayReplies"\
					data-enable-border="adv.enableBorder"\
					data-group-by="adv.groupBy"\
				    data-set-diges-min-max-width= "adv.setDigesMinMaxWidth()"\
					data-get-title-styles = "adv.getTitleStyles()"\
					data-alternate-image-styles = "adv.alternateImageStyles()"\
					data-set-rep-digest-styles = "adv.setRepDigestStyles(digest)"\
					data-get-annotated-text = "adv.getAnnotatedText(annotation)"\
					data-format-created-date = "adv.formatCreatedDate(dateValue)"\
					data-format-comment="adv.formatComment(annotation,comment)"\
			    	comment-icon-url = "adv.commentIconUrl"\
					></annotaion-digest-template>';
				
				gptmpl = gptmpl+' template-url="'+templateUrl+'" \
					data-content-editable="'+contenteditable+'"\
					task-space="taskspace"\
					data-digest-for="adv.digestFor"\
					data-digest-meta-info-options="adv.digestMetaInfoOptions"\
					data-image-position="adv.imagePosition"\
					data-table-of-contents="adv.tableOfContents"\
					data-table-of-contents-heading="{{adv.tableOfContentsHeading}}"\
					data-display-order="adv.displayOrder"\
					data-display-replies="adv.displayReplies"\
					data-enable-border="adv.enableBorder"\
					data-group-by="adv.groupBy"\
					data-set-diges-min-max-width= "adv.setDigesMinMaxWidth()"\
					data-get-title-styles = "adv.getTitleStyles()"\
					data-alternate-image-styles = "adv.alternateImageStyles()"\
					data-set-rep-digest-styles = "adv.setRepDigestStyles(digest)"\
					data-get-annotated-text = "adv.getAnnotatedText(annotation)"\
					data-format-created-date = "adv.formatCreatedDate(dateValue)"\
					data-format-comment="adv.formatComment(annotation,comment)"\
			    	comment-icon-url = "adv.commentIconUrl"\
					></annotaion-digest-group-template>';
				
				var template = angular.element(tmpl);
				if(config.groupBy == "tag" || config.groupBy == "taghierarchical" || config.groupBy == "section") {
					template = angular.element(gptmpl);
				} else {
				    template = angular.element(tmpl);
				}
				var linkFunction = $compile(template);
				var result = linkFunction($scope);
				$scope.$digest();
				if(saveflag) {
					var rootTemplate = $templateCache.get(roottemplateUrl);
					if(!_.isEmpty(rootTemplate)) {
						return rootTemplate.replace("<!--digestdata-->",template.html());
					}
					return template.html();
				} else {
					return template.html();
				}
			}, 0);
		}
		
		function annotationsDigest(event,digestFor) {
			if(event) {
				event.stopPropagation();
			}
			
			var modalInstance = $uibModal.open({
			      animation: true,
			      templateUrl: 'app/components/AnnotationDigest/create/AnnotationDigest.html',
			      controller: 'AnnotationDigestController',
			      appendTo : $('.rootContainer'),
			      controllerAs: 'ad',
			      backdrop: 'static',
			      size: "lg",
			      resolve: {
				      taskspaceInfo: function() {
					    return {
							"tsId" : $scope.tsId,
							"tsClientId" : $scope.tsClientId
						}
					  },
				      systemSttings: function() {
					     return commonService.getNavMenuItems({type: "GlobalSettings",key:"DigestTableOfContents"}).then(function(resp) {
							if(resp.data.Status && !_.isEmpty(resp.data.listAppKeyValues)) {
								return resp.data.listAppKeyValues[0];
							} else {
								return {};
							}
						 });
					  },
			    	  settings : function() {
			    		  return TaskSpaceService.getTaskSpaceState($scope.tsClientId, $scope.tsId).then(function(resp) {
			    			  if (resp.status == 200 && resp.data.Status) {
			  					return resp.data.TaskspaceState;
			    			  } 
			    		  });
			    	  },
			    	  /*templates: function() {
			    		  return digestTemplates;
			    	  },*/
			    	  digestFor: function() {
			    		  var data = {"digestFor" : digestFor};
			    		  if(digestFor == "AnnotationDigest") {
			    			  data["digestName"] = $scope.taskspace.name+ " Digest";
			    			  var appdata = appData.getAppData();
			    			  if(appdata.UserId == $scope.taskspace.owner) {
			    				  data["tsDefaultFolderId"] = $scope.taskspace.defaultFolderId;
			    			  }
			    		  } else if(digestFor == "settings") {
			    			  data["digestName"] = $scope.taskspace.name+ " Digest";
			    		  }
			    		  return data;
			    	  },
			    	  linkInfo: function() {
			    		  if(digestFor == "AnnotationDigest") {
			    			  var postdata = {
			    					  "objectType" : "AnnotationDigest",
			    					  "linkObjectId" : $scope.tsId,
			    					  "clientId" : $scope.tsClientId
			    			  };
			    			  return DeepLinkService.checkLinkExists(postdata).then(function(resp) {
				    			  if (resp.status == 200 && resp.data.Status) {
				    				  if(!_.isEmpty(resp.data.Link)) {
				    					  return resp.data.Link;
				    				  } else {
				    					  return {};
				    				  }
				    			  } 
				    		  }); 
			    		  } else {
			    			  return {};
			    		  }
			    	  }
			      }
			    });
			
			modalInstance.result.then(function (result) {	
				config = angular.copy(result.digestsettings);
				adv.digestMetaInfoOptions = angular.copy(config.digestMetaInfoOptions);
				adv.enableBorder = angular.copy(config.enableBorder);
				adv.groupBy = angular.copy(config.groupBy);
				adv.sortBy = angular.copy(config.sortBy);
				adv.includeDocsWithoutAnn = angular.copy(config.includeDocsWithoutAnn);
				AnnotationDigestService.enableBorder = "";
				AnnotationDigestService.enableBorder = adv.enableBorder;
				adv.imagePosition = angular.copy(config.imagePosition);
				adv.tableOfContents = angular.copy(config.tableOfContents);
				adv.tableOfContentsHeading = angular.copy(config.tableOfContentsHeading);
				adv.displayOrder = angular.copy(config.displayOrder);
				adv.displayReplies = angular.copy(config.filterOptions.displayReplies);
				if(result.digestsettings.save) {
					delete result.digestsettings.save;
					delete config.save;
					result.clientId = $scope.tsClientId;
					var accessedFrom = "viewDigest";
					var fromSource = "FromNumici";
					if($stateParams.digest) {
						accessedFrom = "liveDigest";
						fromSource = "FromNumici";
					}
					if(!_.isEmpty(accessedFrom)) {
						result["accessedFrom"] = accessedFrom;
					}
					if(!_.isEmpty(fromSource)) {
						result["fromSource"] = fromSource;
					}
					result["action"] = "saveDigestSettings";
					TaskSpaceService.saveTaskSpaceState(result).then(function(resp) {
						if(resp.status == 200 && resp.data.Status) {
							$scope.$emit("tsStateChanged",resp.data.TaskspaceState);
							APIUserMessages.success("Digest save success");
							createAnnotationDigest();
						}
					}).catch(function() {
						APIUserMessages.error("Digest save failed");
						createAnnotationDigest();
					});
				} else {
					delete config.save;
					createAnnotationDigest();
				}
			});
		}
		
		function showOpenDigestInNewTabBtn() {
			if($state.current.name == "tsdigestview" && $window.opener && !adv.createDigestForLink) {
				return true;
			}
			return false;
		}
		
		function showCloseDigestBtn() {
			if($state.current.name == "tsdigestview" && $window.opener && !adv.createDigestForLink) {
				return true;
			}
			return false;
		}
		
		function openDigestInNewTab() {
			 window.open($window.location.href,"_blank");
			 closeDigestView();
		}
		
		function closeDigestView() {
			if(!$window.opener) {
				console.log("Parent window closed");
				return;
			}
			var oAuthResponse = {type:"view_ts_digest",code:"ViewTaskSpaceDigest",state:"Success",data:{}};
			$window.opener.postMessage(oAuthResponse,origin);
			$window.close();
		}
		
		function shareDigestLink(event, digestFor) {
			if(event) {
				event.stopPropagation();
			}
			var digestSettings;
			var digestFor = {"digestFor" : "AnnotationDigest"};
			digestFor["digestName"] = $scope.taskspace.name+ " Digest";
			
			var modalInstance = $uibModal.open({
			      animation: true,
			      templateUrl: 'app/components/common/ShareLink/ShareLink.html',
			      controller: 'ShareLinkController',
			      appendTo : $('.rootContainer'),
			      controllerAs: 'slc',
			      backdrop: 'static',
			      size: "md",
			      resolve: {
				      taskspaceInfo: function() {
					    return {
							"tsId" : $scope.tsId,
							"tsClientId" : $scope.tsClientId
						}
					  },
				      systemSttings: function() {
					     return commonService.getNavMenuItems({type: "GlobalSettings",key:"DigestTableOfContents"}).then(function(resp) {
							if(resp.data.Status && !_.isEmpty(resp.data.listAppKeyValues)) {
								return resp.data.listAppKeyValues[0];
							} else {
								return {};
							}
						 });
					  },
			    	  settings : function() {
			    		  return TaskSpaceService.getTaskSpaceState($scope.tsClientId , $scope.tsId).then(function(resp) {
			    			  if (resp.status == 200 && resp.data.Status) {
			    				var settings = resp.data.TaskspaceState;
			    				digestSettings = settings.digestsettings;
			  					return settings;
			    			  } 
			    		  });
			    	  },
			    	  digestFor: function() {
			    		  return digestFor;
			    	  },
			    	  linkInfo: ['DeepLinkService','AnnotationDigestService','$q',function(DeepLinkService,AnnotationDigestService,$q) {
			    		  var deferred = $q.defer();
			    		  var postdata = {
	    					  "objectType" : "AnnotationDigest",
	    					  "linkObjectId" : $scope.tsId,
	    					  "clientId" : $scope.tsClientId
		    			  };
		    			  DeepLinkService.checkLinkExists(postdata).then(function(resp) {
			    			  if (resp.status == 200 && resp.data.Status) {
			    				  if(!_.isEmpty(resp.data.Link)) {
			    					  deferred.resolve(resp.data.Link);
			    				  } else {
			    					  var timer1 = $timeout(function() {
				    					  if(!_.isEmpty(digestSettings)){
				    						  digestSettings["objectId"] = $scope.tsId;
				    						  digestSettings["clientId"] = $scope.tsClientId;
				    						  digestSettings["context"] = "taskspace";
				    					  } else {
				    						  digestSettings = AnnotationDigestService.getDefaultDigestSettings($scope.tsId, $scope.tsClientId);
				    					  }
				    					  if(_.isEmpty(digestSettings.digestName)){
					    					  digestSettings["digestName"] = $scope.taskspace.name+ " Digest";  
				    					  }
				    					  var lnk = AnnotationDigestService.processLinkInfo(digestFor, $scope.tsId, $scope.tsClientId, digestSettings);
			    						  DeepLinkService.createLink(lnk).then(function(createLinkResp) {
			    							  if(createLinkResp.status == 200 && createLinkResp.data.Status) {
			    								  deferred.resolve(createLinkResp.data.Link);
			    							  }
			    						  });
			    						  $timeout.cancel(timer1);
			    					  }, 100);
			    				  }
			    			  } 
			    		  });
		    			  return deferred.promise;
			    	  }]
			      }
			    });
			
			modalInstance.result.then(function (result) {
			});
		}
		
		function handleAnnotationDigest(resp,deepLinkId) {
			if(resp.status == 200 && resp.data.Status) {
				if(_.isEmpty(resp.data.AnnotationDigest)) {
					if(!_.isEmpty(resp.data.Message)) {
						MessageService.showErrorMessage("BACKEND_ERR_MSG",[resp.data.Message]);
					} else {
						MessageService.showInfoMessage("ANNOTATION_DIGEST_NODATA_INFO");
					}
					adv.digestData = [];
				} else {
					//Added this condition for createDigestForLink because in createDigestForLink response is comming resp.data.AnnotationDigest.AnnotationDigest
					
					var linkAnnotationDigestResp = resp.data.AnnotationDigest;
					trustedAnnotatedText = {};
					if(!_.isEmpty(deepLinkId)) {
						preProcessAnnotationDigestResp(false,linkAnnotationDigestResp,deepLinkId);
					} else {
						preProcessAnnotationDigestResp(false,linkAnnotationDigestResp);
					}
				}
			}
			
			getDigestContent(false,false).then(function(content) {
				//var divElement = $element.find('.digest-content');
				//divElement.empty();
				//divElement.append(content);
				adv.digestContent = content;
				$scope.$emit("objectLoaded",false);
				var timer = $timeout(function() {
					var iframeDoc = (document.getElementsByTagName('iframe')[0]).contentWindow;
					if(iframeDoc && iframeDoc.document && iframeDoc.document.body) {
						$(iframeDoc.document.body).find('.cke_widget_drag_handler_container').css("display", "none");
						$(iframeDoc.document.body).find('.cke_image_resizer').css("display", "none");
					}
					$timeout.cancel(timer);
		        }, 2000);
		        AnnotationDigestService.addBoxShadowToDigest(config.groupBy);
			}); 
		}
		
		function hideLoader() {
			$timeout(function() {
				adv.loader = false;
			},100);
		}
			
		function createAnnotationDigest(accessedFrom,fromSource,cb,isDocsUpdated) {
			adv.loader = true;
			if(adv.createDigestForLink) {
				/*TemplateService.listActiveDigestTemplates().then(function(resp) {
		  			  if(resp.status == 200 && resp.data.Status) {
		  				digestTemplates = resp.data.listTemplates;
		  				if(digestTemplates) {
		  					_.each(digestTemplates,function(val,index) {
		  						$templateCache.put(val.id+".html", val.template);
		  					});
		  				}
		  			  } 
		  		}).finally(function() {
		  			
		  		});*/
				AnnotationDigestService.createForLink({linkId : $stateParams.linkId,clientId : $stateParams.linkClientId}).then(function(resp) {
	  				if(resp.status == 200 && resp.data.Status) {
	  					var appdata = appData.getAppData();
	  					if(resp.data.digestName && $state.current.name == "digestlink"){
								$scope.$emit("PageName",{"userName":appdata.UserName,"pageName":resp.data.digestName,"companyName":""});
						}
	  					config = angular.copy(AnnotationDigestService.getDigestFilters());
	  					if(!_.isEmpty(resp.data.digestSettings)) {
	  						config = angular.copy(resp.data.digestSettings);
	  						$scope.tsId = config.objectId;
	  						$scope.tsClientId = config.clientId;
	  					}
	  					if(!_.isEmpty(resp.data.objectType)) {
	  						adv.digestFor = resp.data.objectType;
	  					}
	  					if(!_.isEmpty(resp.data.docId)) {
	  						$scope.docId = resp.data.docId;
	  					}
		  				config.sortOptions = _.isEmpty(config.sortOptions) ? {"timestamp" : "desc"} : config.sortOptions;
	  					config.groupBy = _.isEmpty(config.groupBy) ? "document" : config.groupBy;
	  					config.sortBy = _.isEmpty(config.sortBy) ? {"field": "name","order": "asc"} : config.sortBy;
	  					adv.digestMetaInfoOptions = angular.copy(config.digestMetaInfoOptions);
	  					adv.enableBorder = angular.copy(config.enableBorder);
	  					adv.groupBy = angular.copy(config.groupBy);
	  					adv.sortBy = angular.copy(config.sortBy);
	  					adv.includeDocsWithoutAnn = angular.copy(config.includeDocsWithoutAnn);
	  					adv.imagePosition = angular.copy(config.imagePosition);
						adv.tableOfContents = angular.copy(config.tableOfContents);
						adv.tableOfContentsHeading = angular.copy(config.tableOfContentsHeading);
	  					adv.displayOrder = angular.copy(config.displayOrder);
	  					adv.displayReplies = angular.copy(config.filterOptions.displayReplies);
	  					handleAnnotationDigest(resp,resp.data.dlId);
	  					if(typeof cb == "function") {
	  						cb();
	  					}
	  				}
				}).finally(function() {
					hideLoader();
				});
  			} else {
  				if($state.current.name == "tsdigestview" && !_.isEmpty(config.digestName)){
					$scope.$emit("PageName",{"userName":appdata.UserName,"pageName":config.digestName,"companyName":"Curated using Numici"});
				}
  				var includeDocsWithoutAnn = config.includeDocsWithoutAnn;
  				if(config.groupBy != "document" && config.groupBy != "section" 
  					&& config.groupBy != "tag" && config.groupBy != "taghierarchical"){
  					includeDocsWithoutAnn = false;
  				}
  				var includeDocsWithoutSection = config.includeDocsWithoutSection;
  				if(config.groupBy != "section"){
  					includeDocsWithoutSection = false;
  				}
  				var postdata = {
  						"objectId": $scope.tsId, 
  						"clientId": $scope.tsClientId,
  						"context" : "taskspace",
  						"filterOptions" : config.filterOptions,
  						"sortOptions" : config.sortOptions,
  						"groupBy": config.groupBy,
  						"includeDocsWithoutAnn": includeDocsWithoutAnn,
  						"includeDocsWithoutSection" : includeDocsWithoutSection,
  						"sortBy" : config.sortBy
  				};
  				
  				if(config.groupBy == "document" && (_.isEmpty(config.docorder) || isDocsUpdated)) {
  					postdata["docorder"] = AnnotationDigestService.getDocOrder($scope.taskspace);
  				} else if(!_.isEmpty(config.docorder)) {
  					postdata["docorder"] = config.docorder;
  				}
  				
  				if(config.groupBy == "section" && (_.isEmpty(config.secorder) || isDocsUpdated)) {
  					postdata["secorder"] = AnnotationDigestService.getSecOrder($scope.taskspace,config.includeDocsWithoutSection);
  				} else if(!_.isEmpty(config.secorder)) {
  					postdata["secorder"] = config.secorder;
  				}
  				
  				if( !moment(postdata.filterOptions.endDate,defautlDateFormat,true).isValid()) {
  					postdata.filterOptions.endDate = null;
  				}
  				
  				if( !moment(postdata.filterOptions.startDate,defautlDateFormat,true).isValid()) {
  					postdata.filterOptions.startDate = null;
  				}
  				if(!_.isEmpty(accessedFrom)) {
					postdata["accessedFrom"] = accessedFrom;
				}
				if(!_.isEmpty(fromSource)) {
					postdata["fromSource"] = fromSource;
				}
				
  				/*TemplateService.listActiveDigestTemplates().then(function(resp) {
  		  			  if(resp.status == 200 && resp.data.Status) {
  		  				digestTemplates = resp.data.listTemplates;
  		  				if(digestTemplates) {
  		  					_.each(digestTemplates,function(val,index) {
  		  						$templateCache.put(val.id+".html", val.template);
  		  					});
  		  				}
  		  			  } 
  		  		}).finally(function() {
  		  			
  		  		});*/
				AnnotationDigestService.create(postdata).then(function(resp) {
	  				adv.enableBorder = angular.copy(config.enableBorder);
	  				adv.groupBy = angular.copy(config.groupBy);
	  				adv.sortBy = angular.copy(config.sortBy);
	  				adv.includeDocsWithoutAnn = angular.copy(config.includeDocsWithoutAnn);
	  				adv.imagePosition = angular.copy(config.imagePosition);
	  				adv.tableOfContents = angular.copy(config.tableOfContents);
	  				adv.tableOfContentsHeading = angular.copy(config.tableOfContentsHeading);
	  				adv.displayOrder = angular.copy(config.displayOrder);
	  				adv.displayReplies = angular.copy(config.filterOptions.displayReplies);
	  				handleAnnotationDigest(resp);
	  				if(typeof cb == "function") {
  						cb();
  					}
	  			}).finally(function() {
					hideLoader();
				});
  			}
		}
		
		function connectDigestEventSocket() {
			if(!_.isEmpty($scope.tsId) && DigestEventListner.isConnected()) {
				var socketMessage = {"taskspaceId":$scope.tsId};
				if(adv.digestFor == "DigestDocument" && !_.isEmpty($scope.docId)) {
					socketMessage["documentId"] = $scope.docId;
    			}
				DigestEventListner.sendMessage(socketMessage);
    		} else if(!_.isEmpty($scope.tsId) && !DigestEventListner.isConnected()) {
    			DigestEventListner.taskspaceId = $scope.tsId;
    			if(adv.digestFor == "DigestDocument" && !_.isEmpty($scope.docId)) {
    				DigestEventListner.documentId = $scope.docId;
    			}
    			DigestEventListner.reconnect();
			}
		}
		
		function init() {
			if(!_.isEmpty($stateParams.linkId) && !_.isEmpty($stateParams.linkClientId)) {
				adv.createDigestForLink = true;
			}
			if(adv.createDigestForLink) {
				createAnnotationDigest(null,null,function(){
					connectDigestEventSocket();
				});
			} else {
				if($stateParams.digest) {
					createAnnotationDigest("liveDigest","FromNumici");
				} else {
					createAnnotationDigest("viewDigest","FromNumici");
				}
			}
		}
		init();
	}	
	
})();